Index: app/fork.cc
===================================================================
--- app/fork.cc	(revision 3599)
+++ app/fork.cc	(working copy)
@@ -1 +1,139 @@
-link ../src/abstraction/task_test.cc
\ No newline at end of file
+// EPOS Task Test Program
+
+#include <stub/ostream.h>
+#include <stub/alarm.h>
+#include <stub/thread.h>
+#include <stub/task.h>
+
+using namespace EPOS::APPLICATION;
+
+const int iterations = 10;
+
+int func_a(void);
+int func_b(void);
+
+Thread * a;
+Thread * b;
+Thread * m;
+
+
+int main()
+{
+    OStream cout;
+    Endl endl;
+
+    cout << "Task test" << endl;
+
+    m = Thread::self();
+
+    cout << "I'll try to clone myself:" << endl;
+
+    Task * task0 = Task::self();
+    Address_Space * as0 = task0->address_space();
+
+    cout << "My address space's page directory is located at " << "as0->pd()" << endl;
+
+    Segment * cs0 = task0->code_segment();
+    Log_Addr code0 = task0->code();
+    cout << "My code segment is located at "
+         << static_cast<void *>(code0)
+         << " and it is " << cs0->size() << " bytes long" << endl;
+
+    Segment * ds0 = task0->data_segment();
+    Log_Addr data0 = task0->data();
+    cout << "My data segment is located at "
+         << static_cast<void *>(data0)
+         << " and it is " << ds0->size() << " bytes long" << endl;
+
+    cout << "Creating and attaching segments:" << endl;
+    Segment cs1(cs0->size());
+    Log_Addr code1 = as0->attach(cs1);
+    cout << "  code => " << "code1" << " done!" << endl;
+    Segment ds1(ds0->size());
+    Log_Addr data1 = as0->attach(ds1);
+    cout << "  data => " << "data1 "<< " done!" << endl;
+
+    cout << "&code0=" << &code0 << endl;
+    cout << "&code1=" << &code1 << ", size=" << cs0->size() << endl;
+
+    cout << "Copying segments:";
+    memcpy(code1, code0, cs1.size());
+    cout << " code => done!" << endl;
+    memcpy(data1, data0, ds1.size());
+    cout << " data => done!" << endl;
+
+    cout << "Detaching segments:";
+    as0->detach(cs1);
+    as0->detach(ds1);
+    cout << " done!" << endl;
+
+    cout << "Creating the clone task:";
+    Task * task1 = new Task(cs1, ds1);
+    cout << " done!" << endl;
+
+    cout << "Creating a thread over the cloned task:";
+    a = new Thread(task1, &func_a);
+    cout << " done!" << endl;
+
+    cout << "Creating a thread over the main task:";
+    b = new Thread(&func_b);
+    cout << " done!" << endl;
+
+    cout << "I'll now suspend my self to see the other threads running:" << endl;
+    m->suspend();
+
+    cout << "Both threads are now done and have suspended themselves. I'll now wait for 1 second and then wake them up so they can exit ..." << endl;
+
+    Alarm::delay(1000000);
+
+    a->resume();
+    b->resume();
+
+    int status_a = a->join();
+    int status_b = b->join();
+
+    cout << "Thread A exited with status " << status_a << " and thread B exited with status " << status_b << "." << endl;
+
+    delete a;
+    delete b;
+    delete task1;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+
+int func_a(void)
+{
+    OStream cout;
+    Endl endl;
+
+    for(int i = iterations; i > 0; i--) {
+        for(int i = 0; i < 79; i++)
+            cout << "a";
+        cout << endl;
+        Thread::yield();
+    }
+
+    Thread::self()->suspend();
+    return 'A';
+}
+
+int func_b(void)
+{
+    OStream cout;
+    Endl endl;
+
+    for(int i = iterations; i > 0; i--) {
+        for(int i = 0; i < 79; i++)
+            cout << "b";
+        cout << endl;
+        Thread::yield();
+    }
+
+    m->resume();
+
+    Thread::self()->suspend();
+    return 'B';
+}
Index: app/fork_traits.h
===================================================================
--- app/fork_traits.h	(revision 3599)
+++ app/fork_traits.h	(working copy)
@@ -1 +1,161 @@
-link ../src/abstraction/task_test_traits.h
\ No newline at end of file
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Global Configuration
+template<typename T>
+struct Traits
+{
+    static const bool enabled = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+};
+
+template<> struct Traits<Build>
+{
+    enum {LIBRARY, BUILTIN, KERNEL};
+    static const unsigned int MODE = KERNEL;
+
+    enum {IA32};
+    static const unsigned int ARCHITECTURE = IA32;
+
+    enum {PC};
+    static const unsigned int MACHINE = PC;
+
+    enum {Legacy};
+    static const unsigned int MODEL = Legacy;
+
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // > 1 => NETWORKING
+};
+
+
+// Utilities
+template<> struct Traits<Debug>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<void>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<void>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<void>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<void>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<void>
+{
+};
+
+template<> struct Traits<Init>: public Traits<void>
+{
+};
+
+
+// Mediators
+template<> struct Traits<Serial_Display>: public Traits<void>
+{
+    static const bool enabled = true;
+    static const int COLUMNS = 80;
+    static const int LINES = 24;
+    static const int TAB_SIZE = 8;
+};
+
+__END_SYS
+
+#include __ARCH_TRAITS_H
+#include __MACH_CONFIG_H
+#include __MACH_TRAITS_H
+
+__BEGIN_SYS
+
+
+// Abstractions
+template<> struct Traits<Application>: public Traits<void>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<void>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = (mode != Traits<Build>::LIBRARY) || Traits<Scratchpad>::enabled;
+
+    enum {FOREVER = 0, SECOND = 1, MINUTE = 60, HOUR = 3600, DAY = 86400, WEEK = 604800, MONTH = 2592000, YEAR = 31536000};
+    static const unsigned long LIFE_SPAN = 1 * HOUR; // in seconds
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<void>
+{
+    static const bool smp = Traits<System>::multicore;
+
+    typedef Scheduling_Criteria::FCFS Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+
+    static const bool trace_idle = hysterically_debugged;
+};
+
+template<> struct Traits<Scheduler<Thread> >: public Traits<void>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+
+template<> struct Traits<Address_Space>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multiheap;
+};
+
+template<> struct Traits<Segment>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multiheap;
+};
+
+template<> struct Traits<Alarm>: public Traits<void>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+__END_SYS
+
+#endif
Index: app/makefile
===================================================================
--- app/makefile	(revision 3599)
+++ app/makefile	(working copy)
@@ -14,4 +14,4 @@
 		$(INSTALL) $(APPLICATION) $(IMG)
 
 clean:
-		$(CLEAN) *.o $(APPLICATION)
\ No newline at end of file
+		$(CLEAN) *.o $(APPLICATION)
Index: app/philosophers_dinner.cc
===================================================================
--- app/philosophers_dinner.cc	(revision 3599)
+++ app/philosophers_dinner.cc	(working copy)
@@ -1 +1,105 @@
-link ../src/abstraction/semaphore_test.cc
\ No newline at end of file
+// EPOS Semaphore Abstraction Test Program
+
+#include <utility/ostream.h>
+#include <thread.h>
+#include <mutex.h>
+#include "semaphore.h"
+#include <alarm.h>
+#include <display.h>
+
+//using namespace EPOS;
+
+const int iterations = 10;
+
+Mutex table;
+S::Thread * phil[5];
+Semaphore * chopstick[5];
+
+S::OStream cout;
+
+int philosopher(int n, int l, int c)
+{
+    int first = (n < 4)? n : 0;
+    int second = (n < 4)? n + 1 : 4;
+
+    for(int i = iterations; i > 0; i--) {
+
+        table.lock();
+        S::Display::position(l, c);
+        cout << "thinking";
+        table.unlock();
+
+        S::Delay thinking(2000000);
+
+        chopstick[first]->p();   // get first chopstick
+        chopstick[second]->p();   // get second chopstick
+
+        table.lock();
+        S::Display::position(l, c);
+        cout << " eating ";
+        table.unlock();
+
+        S::Delay eating(1000000);
+
+        chopstick[first]->v();   // release first chopstick
+        chopstick[second]->v();   // release second chopstick
+    }
+
+    table.lock();
+    S::Display::position(l, c);
+    cout << "  done  ";
+    table.unlock();
+
+    return iterations;
+}
+
+int main()
+{
+    table.lock();
+    S::Display::clear();
+    S::Display::position(0, 0);
+    cout << "The Philosopher's Dinner:" << S::endl;
+
+    for(int i = 0; i < 5; i++)
+        chopstick[i] = new Semaphore;
+
+    phil[0] = new S::Thread(&philosopher, 0,  5, 32);
+    phil[1] = new S::Thread(&philosopher, 1, 10, 44);
+    phil[2] = new S::Thread(&philosopher, 2, 16, 39);
+    phil[3] = new S::Thread(&philosopher, 3, 16, 24);
+    phil[4] = new S::Thread(&philosopher, 4, 10, 20);
+
+    cout << "Philosophers are alive and hungry!" << EPOS::S::endl;
+
+    S::Display::position(7, 44);
+    cout << '/';
+    S::Display::position(13, 44);
+    cout << '\\';
+    S::Display::position(16, 35);
+    cout << '|';
+    S::Display::position(13, 27);
+    cout << '/';
+    S::Display::position(7, 27);
+    cout << '\\';
+    S::Display::position(19, 0);
+
+    cout << "The dinner is served ..." << S::endl;
+    table.unlock();
+
+    for(int i = 0; i < 5; i++) {
+        int ret = phil[i]->join();
+        table.lock();
+        S::Display::position(20 + i, 0);
+        cout << "Philosopher " << i << " ate " << ret << " times " << S::endl;
+        table.unlock();
+    }
+
+    for(int i = 0; i < 5; i++)
+        delete chopstick[i];
+    for(int i = 0; i < 5; i++)
+        delete phil[i];
+
+    cout << "The end!" << S::endl;
+
+    return 0;
+}
Index: app/producer_consumer.cc
===================================================================
--- app/producer_consumer.cc	(revision 3599)
+++ app/producer_consumer.cc	(working copy)
@@ -1 +1,55 @@
-link ../src/abstraction/synchronizer_test.cc
\ No newline at end of file
+// EPOS Synchronizer Abstraction Test Program
+
+#include <utility/ostream.h>
+#include <thread.h>
+#include <semaphore.h>
+#include <alarm.h>
+
+using namespace EPOS;
+
+const int iterations = 100;
+
+OStream cout;
+
+const int BUF_SIZE = 16;
+char buffer[BUF_SIZE];
+Semaphore empty(BUF_SIZE);
+Semaphore full(0);
+
+int consumer()
+{
+    int out = 0;
+    for(int i = 0; i < iterations; i++) {
+        full.p();
+        cout << "C<-" << buffer[out] << "\t";
+        out = (out + 1) % BUF_SIZE;
+        Alarm::delay(1000 * out);
+        empty.v();
+    }
+
+    return 0;
+}
+
+int main()
+{
+    Thread * cons = new Thread(&consumer);
+
+    // producer
+    int in = 0;
+    for(int i = 0; i < iterations; i++) {
+        empty.p();
+        Alarm::delay(1000 * in);
+        buffer[in] = 'a' + in;
+        cout << "P->" << buffer[in] << "\t";
+        in = (in + 1) % BUF_SIZE;
+        full.v();
+    }
+
+    cons->join();
+
+    cout << "The end!" << endl;
+
+    delete cons;
+
+    return 0;
+}
Index: include/address_space.h
===================================================================
--- include/address_space.h	(revision 3599)
+++ include/address_space.h	(working copy)
@@ -13,12 +13,13 @@
     friend class Task;
 
 private:
-    typedef CPU::Phy_Addr Phy_Addr;
-    typedef CPU::Log_Addr Log_Addr;
 
     using MMU::Directory::activate;
 
 public:
+    typedef CPU::Phy_Addr Phy_Addr;
+    typedef CPU::Log_Addr Log_Addr;
+
     Address_Space();
     Address_Space(MMU::Page_Directory * pd);
     ~Address_Space();
Index: include/alarm.h
===================================================================
--- include/alarm.h	(revision 3599)
+++ include/alarm.h	(working copy)
@@ -68,6 +68,8 @@
 
 class Delay
 {
+    friend class Skeleton;
+
 private:
     typedef RTC::Microsecond Microsecond;
 
Index: include/architecture/ia32/cpu.h
===================================================================
--- include/architecture/ia32/cpu.h	(revision 3599)
+++ include/architecture/ia32/cpu.h	(working copy)
@@ -43,7 +43,7 @@
         FLAG_DEFAULTS   = FLAG_IF,
         // Mask to clear flags (by ANDing)
         FLAG_CLEAR      = ~(FLAG_TF | FLAG_IOPL1 | FLAG_IOPL2 | FLAG_NT |
-        		    FLAG_RF | FLAG_VM | FLAG_AC)
+                    FLAG_RF | FLAG_VM | FLAG_AC)
     };
 
     // CPU Exceptions
@@ -116,13 +116,13 @@
         SEG_TSS0        = (SEG_PRE  | SEG_TSS   | SEG_DPL2 | SEG_DPL1 )
     };
 
-    // DPL/RPL for application (user) and system (supervisor) modes 
+    // DPL/RPL for application (user) and system (supervisor) modes
     enum {
         PL_APP = 3, // GDT, RPL=3
         PL_SYS = 0  // GDT, RPL=0
     };
 
-    // GDT Layout 
+    // GDT Layout
     enum GDT_Layout { // GCC BUG (anonymous enum in templates)
         GDT_NULL      = 0,
         GDT_FLT_CODE  = 1,
@@ -155,13 +155,13 @@
           g_d_0_a_limit_19_16(((f & SEG_NOSYS) ? (SEG_4K | SEG_32) : 0) | ((Reg8)(l >> 16))), base_31_24((Reg8)(b >> 24)) {}
 
         friend Debug & operator<<(Debug & db, const GDT_Entry & g) {
-            db << "{bas=" << (void *)((g.base_31_24 << 24) | (g.base_23_16 << 16) | g.base_15_00) 
+            db << "{bas=" << (void *)((g.base_31_24 << 24) | (g.base_23_16 << 16) | g.base_15_00)
                << ",lim=" << (void *)(((g.g_d_0_a_limit_19_16 & 0xf) << 16) | g.limit_15_00)
-               << ",p=" << (g.p_dpl_s_type >> 7) 
+               << ",p=" << (g.p_dpl_s_type >> 7)
                << ",dpl=" << ((g.p_dpl_s_type >> 5) & 0x3)
                << ",s=" << ((g.p_dpl_s_type >> 4) & 0x1)
                << ",typ=" << (g.p_dpl_s_type & 0xf)
-               << ",g=" << (g.g_d_0_a_limit_19_16 >> 7) 
+               << ",g=" << (g.g_d_0_a_limit_19_16 >> 7)
                << ",d=" << ((g.g_d_0_a_limit_19_16 >> 6) & 0x1)
                << ",a=" << ((g.g_d_0_a_limit_19_16 >> 4) & 0x1) << "}";
             return db;
@@ -188,7 +188,7 @@
         friend Debug & operator<<(Debug & db, const IDT_Entry & i) {
             db << "{sel=" << i.selector
                << ",off=" << (void *)i.offset()
-               << ",p=" << (i.p_dpl_0_d_1_1_0 >> 7) 
+               << ",p=" << (i.p_dpl_0_d_1_1_0 >> 7)
                << ",dpl=" << ((i.p_dpl_0_d_1_1_0 >> 5) & 0x3)
                << ",d=" << ((i.p_dpl_0_d_1_1_0 >> 4) & 0x1) << "}";
             return db;
@@ -250,7 +250,8 @@
     class Context
     {
     public:
-        Context(const Log_Addr & entry): _eflags(FLAG_DEFAULTS), _eip(entry) {}
+        Context(const Log_Addr & entry): _eip(entry), _cs(SEL_SYS_CODE), _eflags(FLAG_DEFAULTS) {}
+        Context(const Log_Addr & entry, int code_selector): _eip(entry), _cs(code_selector), _eflags(FLAG_DEFAULTS) {}
 
         void save() volatile;
         void load() const volatile;
@@ -267,12 +268,13 @@
                << ",ebp=" << reinterpret_cast<void *>(c._ebp)
                << ",esp=" << &c
                << ",eip=" << reinterpret_cast<void *>(c._eip)
-               << ",cs="  << cs()
-               << ",ds="  << ds()
-               << ",es="  << es()
-               << ",fs="  << fs()
-               << ",gs="  << gs()
-               << ",ss="  << ss()
+               << ",cs="  << c._cs
+               << ",ccs=" << cs()
+               << ",cds=" << ds()
+               << ",ces=" << es()
+               << ",cfs=" << fs()
+               << ",cgs=" << gs()
+               << ",css=" << ss()
                << ",cr3=" << reinterpret_cast<void *>(pdp())
                << "}"     << dec;
             return db;
@@ -287,8 +289,9 @@
         Reg32 _edx;
         Reg32 _ecx;
         Reg32 _eax;
+        Reg32 _eip;
+        Reg32 _cs;
         Reg32 _eflags;
-        Reg32 _eip;
     };
 
     // I/O ports
@@ -362,16 +365,26 @@
     static Reg32 ntohl(Reg32 v)	{ return htonl(v); }
     static Reg16 ntohs(Reg16 v)	{ return htons(v); }
 
-    // IA32 first decrements the stack pointer and then writes into the stack, that's why we decrement it by an int
     template<typename ... Tn>
-    static Context * init_stack(const Log_Addr & stack, unsigned int size, void (* exit)(), int (* entry)(Tn ...), Tn ... an) {
-        Log_Addr sp = stack + size - sizeof(int);
-        sp -= SIZEOF<Tn ... >::Result;
-        init_stack_helper(sp, an ...);
-        sp -= sizeof(int *);
-        *static_cast<int *>(sp) = Log_Addr(exit);
-        sp -= sizeof(Context);
-        return new (sp) Context(entry);
+    static Context * init_stack(Log_Addr sys_sp, Log_Addr usr_sp, bool user_mode, void (* exit)(), int (* entry)(Tn ...), Tn ... an) {
+        // salvar o offset (sp - bp) das pilhas de sistema e usuário
+        // IA32 first decrements the stack pointer and then writes into the stack
+        usr_sp -= SIZEOF<Tn ... >::Result;
+        init_stack_helper(usr_sp, an ...);
+        sys_sp -= sizeof(int *);
+        *static_cast<int *>(sys_sp) = Log_Addr(exit);
+
+        if(user_mode){
+            sys_sp -= sizeof(int *);
+            *static_cast<int *>(sys_sp) = IA32::SEL_APP_DATA; // ss = 0x1B
+            sys_sp -= sizeof(int *);
+            *static_cast<int *>(sys_sp) = usr_sp;             // esp
+            sys_sp -= sizeof(Context);
+            return new (sys_sp) Context(entry, IA32::SEL_APP_CODE);
+        } else {
+            sys_sp -= sizeof(Context);
+            return new (sys_sp) Context(entry);
+        }
     }
 
 public:
@@ -388,7 +401,7 @@
         Reg32 value; ASM("movl %%esp,%0" : "=r"(value) :); return value;
     }
     static void esp(const Reg32 value) {
- 	ASM("movl %0, %%esp" : : "r"(value));
+    ASM("movl %0, %%esp" : : "r"(value));
     }
 
     static Reg32 eax() {
@@ -395,7 +408,7 @@
         Reg32 value; ASM("movl %%eax,%0" : "=r"(value) :); return value;
     }
     static void eax(const Reg32 value) {
- 	ASM("movl %0, %%eax" : : "r"(value));
+    ASM("movl %0, %%eax" : : "r"(value));
     }
 
     static Log_Addr eip() {
@@ -404,7 +417,7 @@
              "		call	1f					\n"
              "1:	popl	%%eax		# ret. addr.		\n"
              "		movl	%%eax,%0				\n"
-             "		popl	%%eax					\n" 
+             "		popl	%%eax					\n"
              : "=o"(value) : );
         return value;
     }
@@ -452,7 +465,7 @@
         *b = base;
         ASM("lgdt %0" : : "m"(aux[0]));
     }
- 
+
     static void idtr(Reg16 * limit, Reg32 * base) {
         volatile Reg8 aux[6];
         volatile Reg16 * l = reinterpret_cast<volatile Reg16 *>(&aux[0]);
Index: include/architecture/ia32/mmu.h
===================================================================
--- include/architecture/ia32/mmu.h	(revision 3599)
+++ include/architecture/ia32/mmu.h	(working copy)
@@ -217,7 +217,7 @@
         Log_Addr attach(const Chunk & chunk, Log_Addr addr) {
             unsigned int from = directory(addr);
             if(!attach(from, chunk.pt(), chunk.pts(), chunk.flags()))
-        	return Log_Addr(false);
+                return Log_Addr(false);
 
             return from << DIRECTORY_SHIFT;
         }
@@ -261,7 +261,7 @@
 
         void detach(unsigned int from, const Page_Table * pt, unsigned int n) {
             for(unsigned int i = from; i < from + n; i++)
-        	(*_pd)[i] = 0;
+                (*_pd)[i] = 0;
         }
 
     private:
Index: include/machine/pc/ic.h
===================================================================
--- include/machine/pc/ic.h	(revision 3599)
+++ include/machine/pc/ic.h	(working copy)
@@ -177,53 +177,53 @@
 
     // Memory-mapped registers
     enum {
-        ID =			0x020,	// Task priority 
-        VERSION =		0x030,	// Task priority 
-        TPR =			0x080,	// Task priority 
-        APR =			0x090,	// Arbitration priority 
-        PPR =			0x0a0,	// Processor priority 
-        EOI =			0x0b0,	// End of interrupt 
-        RRR =			0x0c0,	// Remote read 
-        LDR =			0x0d0,	// Logical destination 
-        DFR =			0x0e0,	// Destination format 
-        SVR =			0x0f0,	// Spurious interrupt vector 
-        ISR0_32 =		0x100,	// In-service 
-        ISR32_63 =		0x110,	// In-service 
-        ISR64_95 =		0x120,	// In-service 
-        ISR96_127 =		0x130,	// In-service 
-        ISR128_159 =		0x140,	// In-service 
-        ISR160_191 =		0x150,	// In-service 
-        ISR192_223 =		0x160,	// In-service 
-        ISR224_255 =		0x170,	// In-service 
-        TMR0_32 =		0x180,	// Trigger mode 
-        TMR32_63 =		0x190,	// Trigger mode 
-        TMR64_95 =		0x1a0,	// Trigger mode 
-        TMR96_127 =		0x1b0,	// Trigger mode 
-        TMR128_159 =		0x1c0,	// Trigger mode 
-        TMR160_191 =		0x1d0,	// Trigger mode 
-        TMR192_223 =		0x1e0,	// Trigger mode 
-        TMR224_255 =		0x1f0,	// Trigger mode 
-        IRR0_32 =		0x200,	// Interrupt request 
-        IRR32_63 =		0x210,	// Interrupt request 
-        IRR64_95 =		0x220,	// Interrupt request 
-        IRR96_127 =		0x230,	// Interrupt request 
-        IRR128_159 =		0x240,	// Interrupt request 
-        IRR160_191 =		0x250,	// Interrupt request 
-        IRR192_223 =		0x260,	// Interrupt request 
-        IRR224_255 =		0x270,	// Interrupt request 
-        ESR =			0x280,	// Error status 
-        LVT_CMCI =		0x2f0,	// LVT CMCI 
-        ICR0_31 =		0x300,	// Interrupt command 
-        ICR32_63 =		0x310,	// Interrupt command 
-        LVT_TIMER =		0x320,	// LVT timer 
-        LVT_THERMAL =		0x330,	// LVT thermal sensor 
-        LVT_PERF =		0x340,	// LVT performance monitor 
-        LVT_LINT0 =		0x350,	// LVT interrupt line 0 
-        LVT_LINT1 =		0x360,	// LVT interrupt line 1 
-        LVT_ERROR =		0x370,	// LVT error 
-        TIMER_INITIAL =		0x380,	// Timer's initial count 
-        TIMER_CURRENT =		0x390,	// Timer's current count 
-        TIMER_PRESCALE =	0x3e0	// Timer's BUS CLOCK prescaler 
+        ID =			0x020,	// Task priority
+        VERSION =		0x030,	// Task priority
+        TPR =			0x080,	// Task priority
+        APR =			0x090,	// Arbitration priority
+        PPR =			0x0a0,	// Processor priority
+        EOI =			0x0b0,	// End of interrupt
+        RRR =			0x0c0,	// Remote read
+        LDR =			0x0d0,	// Logical destination
+        DFR =			0x0e0,	// Destination format
+        SVR =			0x0f0,	// Spurious interrupt vector
+        ISR0_32 =		0x100,	// In-service
+        ISR32_63 =		0x110,	// In-service
+        ISR64_95 =		0x120,	// In-service
+        ISR96_127 =		0x130,	// In-service
+        ISR128_159 =		0x140,	// In-service
+        ISR160_191 =		0x150,	// In-service
+        ISR192_223 =		0x160,	// In-service
+        ISR224_255 =		0x170,	// In-service
+        TMR0_32 =		0x180,	// Trigger mode
+        TMR32_63 =		0x190,	// Trigger mode
+        TMR64_95 =		0x1a0,	// Trigger mode
+        TMR96_127 =		0x1b0,	// Trigger mode
+        TMR128_159 =		0x1c0,	// Trigger mode
+        TMR160_191 =		0x1d0,	// Trigger mode
+        TMR192_223 =		0x1e0,	// Trigger mode
+        TMR224_255 =		0x1f0,	// Trigger mode
+        IRR0_32 =		0x200,	// Interrupt request
+        IRR32_63 =		0x210,	// Interrupt request
+        IRR64_95 =		0x220,	// Interrupt request
+        IRR96_127 =		0x230,	// Interrupt request
+        IRR128_159 =		0x240,	// Interrupt request
+        IRR160_191 =		0x250,	// Interrupt request
+        IRR192_223 =		0x260,	// Interrupt request
+        IRR224_255 =		0x270,	// Interrupt request
+        ESR =			0x280,	// Error status
+        LVT_CMCI =		0x2f0,	// LVT CMCI
+        ICR0_31 =		0x300,	// Interrupt command
+        ICR32_63 =		0x310,	// Interrupt command
+        LVT_TIMER =		0x320,	// LVT timer
+        LVT_THERMAL =		0x330,	// LVT thermal sensor
+        LVT_PERF =		0x340,	// LVT performance monitor
+        LVT_LINT0 =		0x350,	// LVT interrupt line 0
+        LVT_LINT1 =		0x360,	// LVT interrupt line 1
+        LVT_ERROR =		0x370,	// LVT error
+        TIMER_INITIAL =		0x380,	// Timer's initial count
+        TIMER_CURRENT =		0x390,	// Timer's current count
+        TIMER_PRESCALE =	0x3e0	// Timer's BUS CLOCK prescaler
     };
 
     // Flags
@@ -339,7 +339,7 @@
 
     static void reset(Log_Addr addr = LOCAL_APIC_LOG_ADDR) {
         // APIC must be on very early in the boot process, so it is
-        // subject to memory remappings. We also cannot be sure about 
+        // subject to memory remappings. We also cannot be sure about
         // global constructors here
         remap(addr);
         if(Traits<System>::multicore) {
@@ -351,8 +351,8 @@
     }
 
     static int eoi(unsigned int i) { // End of interrupt
-    	write(APIC::EOI, 0);
-    	return true;
+        write(APIC::EOI, 0);
+        return true;
     }
 
     static void config_timer(Reg32 count, bool interrupt, bool periodic) {
@@ -365,10 +365,10 @@
         write(LVT_TIMER, v);
     }
 
-    static void enable_timer() { 
+    static void enable_timer() {
         write(LVT_TIMER, read(LVT_TIMER) & ~TIMER_MASKED);
     }
-    static void disable_timer() { 
+    static void disable_timer() {
         write(LVT_TIMER, read(LVT_TIMER) | TIMER_MASKED);
     }
 
@@ -375,7 +375,7 @@
     static Reg32 read_timer() {
         return read(TIMER_CURRENT);
     }
-    
+
     static void reset_timer() {
         disable();
         write(TIMER_CURRENT, read(TIMER_INITIAL));
@@ -419,7 +419,7 @@
         }
         if(read(VERSION) & 0xf) { // !82489DX
             if(lvts > 3)
-        	write(ESR, 0);
+            write(ESR, 0);
             read(ESR);
         }
     }
@@ -510,14 +510,16 @@
         }
     }
 
+    // Logical handlers
+    static void int_not(const Interrupt_Id & i);
+
+    // Physical handlers
     static void entry();
+    static void exc_not(Reg32 eip, Reg32 cs, Reg32 eflags, Reg32 error);
+    static void exc_pf (Reg32 eip, Reg32 cs, Reg32 eflags, Reg32 error);
+    static void exc_gpf(Reg32 eip, Reg32 cs, Reg32 eflags, Reg32 error);
+    static void exc_fpu(Reg32 eip, Reg32 cs, Reg32 eflags, Reg32 error);
 
-    static void int_not(const Interrupt_Id & i);
-    static void exc_not(const Interrupt_Id & i, Reg32 error, Reg32 eip, Reg32 cs, Reg32 eflags);
-    static void exc_pf (const Interrupt_Id & i, Reg32 error, Reg32 eip, Reg32 cs, Reg32 eflags);
-    static void exc_gpf(const Interrupt_Id & i, Reg32 error, Reg32 eip, Reg32 cs, Reg32 eflags);
-    static void exc_fpu(const Interrupt_Id & i, Reg32 error, Reg32 eip, Reg32 cs, Reg32 eflags);
-
     static void init();
 
 private:
Index: include/stub/stub.h
===================================================================
--- include/stub/stub.h	(revision 0)
+++ include/stub/stub.h	(working copy)
@@ -0,0 +1,18 @@
+#ifndef STUB_H
+#define STUB_H
+
+#include <system/config.h>
+
+__BEGIN_APPLICATION
+
+class Stub
+{
+protected:
+    static void syscall(int * message){
+        ASM("int $50" : : "eax"(message));
+    }
+};
+
+__END_APPLICATION
+
+#endif // STUB_H
Index: include/synchronizer.h
===================================================================
--- include/synchronizer.h	(revision 3599)
+++ include/synchronizer.h	(working copy)
@@ -15,7 +15,7 @@
 
 protected:
     Synchronizer_Common() {}
-    ~Synchronizer_Common() { begin_atomic(); wakeup_all(); }
+    ~Synchronizer_Common() { begin_atomic(); wakeup_all();}
 
     // Atomic operations
     bool tsl(volatile bool & lock) { return CPU::tsl(lock); }
@@ -37,4 +37,3 @@
 __END_SYS
 
 #endif
-
Index: include/system/config.h
===================================================================
--- include/system/config.h	(revision 3599)
+++ include/system/config.h	(working copy)
@@ -7,15 +7,15 @@
 // ARCHITECTURE, MACHINE, AND APPLICATION SELECTION
 // This section is generated automatically from makedefs by $EPOS/etc/makefile
 //============================================================================
-#define MODE xxx
-#define ARCH xxx
-#define MACH xxx
-#define MMOD xxx
-#define APPL xxx
-#define __mode_xxx__
-#define __arch_xxx__
-#define __mach_xxx__
-#define __mmod_xxx__
+#define MODE kernel
+#define ARCH ia32
+#define MACH pc
+#define MMOD legacy
+#define APPL fork
+#define __mode_kernel__
+#define __arch_ia32__
+#define __mach_pc__
+#define __mmod_legacy__
 
 #if defined (__arch_avr__) || defined (__mmod_lm3s811__)
 #define __no_networking__
@@ -29,6 +29,7 @@
         namespace U {}
         using namespace U;
     }
+    namespace APPLICATION{}
 }
 
 #define __BEGIN_API             namespace EPOS {
@@ -35,6 +36,10 @@
 #define __END_API               }
 #define _API                    ::EPOS
 
+#define __BEGIN_APPLICATION     namespace EPOS { namespace APPLICATION {
+#define __END_APPLICATION       } }
+#define __USING_APPLICATION     using namespace EPOS::APPLICATION;
+
 #define __BEGIN_UTIL            namespace EPOS { namespace S { namespace U {
 #define __END_UTIL              }}}
 #define __USING_UTIL            using namespace S::U;
@@ -47,8 +52,8 @@
 
 #ifndef __mode_kernel__
 namespace EPOS {
-    using namespace S;
-    using namespace S::U;
+    using namespace EPOS::S;
+    using namespace EPOS::S::U;
 }
 #endif
 
Index: include/system/traits.h
===================================================================
--- include/system/traits.h	(revision 3599)
+++ include/system/traits.h	(working copy)
@@ -16,8 +16,8 @@
 
 template<> struct Traits<Build>
 {
-    enum {LIBRARY, BUILTIN};
-    static const unsigned int MODE = LIBRARY;
+    enum {LIBRARY, BUILTIN, KERNEL};
+    static const unsigned int MODE = KERNEL;
 
     enum {IA32};
     static const unsigned int ARCHITECTURE = IA32;
@@ -38,8 +38,8 @@
 {
     static const bool error   = true;
     static const bool warning = true;
-    static const bool info    = false;
-    static const bool trace   = false;
+    static const bool info    = true;
+    static const bool trace   = true;
 };
 
 template<> struct Traits<Lists>: public Traits<void>
Index: include/system/types.h
===================================================================
--- include/system/types.h	(revision 3599)
+++ include/system/types.h	(working copy)
@@ -11,6 +11,7 @@
 enum Scratchpad_Allocator { SCRATCHPAD };
 __END_API
 
+
 extern "C"
 {
     void * malloc(size_t);
Index: include/thread.h
===================================================================
--- include/thread.h	(revision 3599)
+++ include/thread.h	(working copy)
@@ -6,6 +6,7 @@
 #include <utility/queue.h>
 #include <utility/handler.h>
 #include <cpu.h>
+#include <mmu.h>
 #include <machine.h>
 #include <system.h>
 #include <scheduler.h>
@@ -69,6 +70,12 @@
     // Thread Queue
     typedef Ordered_Queue<Thread, Criterion, Scheduler<Thread>::Element> Queue;
 
+
+private:
+    template<typename ... Cn, typename ... Tn>
+    Thread(const Configuration & conf, Task * task, bool user_mode, int (* entry)(Tn ...), Tn ... an);
+
+
 public:
     template<typename ... Tn>
     Thread(int (* entry)(Tn ...), Tn ... an);
@@ -129,7 +136,8 @@
 
 protected:
     Task * _task;
-    char * _stack;
+    Segment * _stack;
+    Segment * _user_stack; // atributo novo
     Context * volatile _context;
     volatile State _state;
     Queue * _waiting;
@@ -145,6 +153,7 @@
 
 #include <task.h>
 
+
 __BEGIN_SYS
 
 template<typename ... Tn>
@@ -152,8 +161,19 @@
 : _task(Task::self()), _state(READY), _waiting(0), _joining(0), _link(this, NORMAL)
 {
     lock();
-    _stack = new (SYSTEM) char[STACK_SIZE];
-    _context = CPU::init_stack(_stack, STACK_SIZE, &implicit_exit, entry, an ...);
+
+    _stack      = new (SYSTEM) Segment(STACK_SIZE, MMU::Flags(MMU::IA32_Flags::SYS));
+    _user_stack = new (SYSTEM) Segment(STACK_SIZE);
+
+    Address_Space * this_as = Task::self()->address_space();
+    Log_Addr _sys_stack_addr = this_as->attach(*_stack);
+    Log_Addr _user_stack_addr =this_as->attach(*_user_stack);
+
+    char * user_stack_base = _user_stack_addr + STACK_SIZE;
+    char * sys_stack_base  = _sys_stack_addr + STACK_SIZE;
+
+    _context = CPU::init_stack(sys_stack_base, user_stack_base, true, &implicit_exit, entry, an ...);
+
     constructor(entry, STACK_SIZE); // implicit unlock
 }
 
@@ -162,8 +182,26 @@
 : _task(task), _state(READY), _waiting(0), _joining(0), _link(this, NORMAL)
 {
     lock();
-    _stack = new (SYSTEM) char[STACK_SIZE];
-    _context = CPU::init_stack(_stack, STACK_SIZE, &implicit_exit, entry, an ...);
+
+    _stack      = new (SYSTEM) Segment(STACK_SIZE, MMU::Flags(MMU::IA32_Flags::SYS));
+    _user_stack = new (SYSTEM) Segment(STACK_SIZE);
+
+    Address_Space * this_as = Task::self()->address_space();
+    this_as->attach(*_stack);
+    this_as->attach(*_user_stack);
+
+    Address_Space * as = task->address_space();
+    Log_Addr _sys_stack_addr = as->attach(*_stack);
+    Log_Addr _user_stack_addr = as->attach(*_user_stack);
+
+    char * user_stack_base = _user_stack_addr + STACK_SIZE;
+    char * sys_stack_base  = _sys_stack_addr + STACK_SIZE;
+
+    _context = CPU::init_stack(sys_stack_base, user_stack_base, true, &implicit_exit, entry, an ...);
+
+    this_as->detach(*_stack);
+    this_as->detach(*_user_stack);
+
     constructor(entry, STACK_SIZE); // implicit unlock
 }
 
@@ -172,8 +210,18 @@
 : _task(Task::self()), _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
 {
     lock();
-    _stack = new (SYSTEM) char[conf.stack_size];
-    _context = CPU::init_stack(_stack, conf.stack_size, &implicit_exit, entry, an ...);
+
+    _stack      = new (SYSTEM) Segment(conf.stack_size, MMU::Flags(MMU::IA32_Flags::SYS));
+    _user_stack = new (SYSTEM) Segment(STACK_SIZE);
+
+    Address_Space * as = Task::self()->address_space();
+    Log_Addr _sys_stack_addr  = as->attach(*_stack);
+    Log_Addr _user_stack_addr = as->attach(*_user_stack);
+
+    char * user_stack_base = _user_stack_addr + STACK_SIZE;
+    char * sys_stack_base = _sys_stack_addr + conf.stack_size;
+
+    _context = CPU::init_stack(sys_stack_base, user_stack_base, true, &implicit_exit, entry, an ...);
     constructor(entry, conf.stack_size); // implicit unlock
 }
 
@@ -182,12 +230,58 @@
 : _task(task), _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
 {
     lock();
-    _stack = new (SYSTEM) char[conf.stack_size];
-    _context = CPU::init_stack(_stack, conf.stack_size, &implicit_exit, entry, an ...);
+
+    _stack      = new (SYSTEM) Segment(conf.stack_size, MMU::Flags(MMU::IA32_Flags::SYS));
+    _user_stack = new (SYSTEM) Segment(STACK_SIZE);
+
+    Address_Space * this_as = Task::self()->address_space();
+    Log_Addr _sys_stack_addr = this_as->attach(*_stack);
+    Log_Addr _user_stack_addr =this_as->attach(*_user_stack);
+
+    Address_Space * as = _task->address_space();
+    as->attach(*_stack);
+    as->attach(*_user_stack);
+
+    char * user_stack_base = _user_stack_addr + STACK_SIZE;
+    char * sys_stack_base  = _sys_stack_addr + STACK_SIZE;
+
+    _context = CPU::init_stack(sys_stack_base, user_stack_base, true, &implicit_exit, entry, an ...);
+
+    this_as->detach(*_stack);
+    this_as->detach(*_user_stack);
+
     constructor(entry, conf.stack_size); // implicit unlock
 }
 
+template<typename ... Cn, typename ... Tn>
+inline Thread::Thread(const Configuration & conf, Task * task, bool user_mode, int (* entry)(Tn ...), Tn ... an)
+: _task(task), _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
+{
+    lock();
 
+    _stack      = new (SYSTEM) Segment(conf.stack_size, MMU::Flags(MMU::IA32_Flags::SYS));
+    _user_stack = new (SYSTEM) Segment(STACK_SIZE);
+
+    Address_Space * this_as = Task::self()->address_space();
+    this_as->attach(*_stack);
+    this_as->attach(*_user_stack);
+
+    Address_Space * as = _task->address_space();
+    Log_Addr _sys_stack_addr = as->attach(*_stack);
+    Log_Addr _user_stack_addr = as->attach(*_user_stack);
+
+    char * user_stack_base = _user_stack_addr + STACK_SIZE;
+    char * sys_stack_base  = _sys_stack_addr + STACK_SIZE;
+
+    _context = CPU::init_stack(sys_stack_base, user_stack_base, user_mode, &implicit_exit, entry, an ...);
+
+    this_as->detach(*_stack);
+    this_as->detach(*_user_stack);
+
+    constructor(entry, conf.stack_size); // implicit unlock
+}
+
+
 // An event handler that triggers a thread (see handler.h)
 class Thread_Handler : public Handler
 {
Index: include/utility/ostream.h
===================================================================
--- include/utility/ostream.h	(revision 3599)
+++ include/utility/ostream.h	(working copy)
@@ -5,7 +5,7 @@
 #ifndef __ostream_h
 #define __ostream_h
 
-extern "C" { void _print(const char * s); }
+extern "C" { void _print(const char *); }
 
 __BEGIN_UTIL
 
Index: makedefs
===================================================================
--- makedefs	(revision 3599)
+++ makedefs	(working copy)
@@ -67,7 +67,7 @@
 COMP_PREFIX		= $($(ARCH)_COMP_PREFIX)
 
 # Boot Memory Map
-MACH_TRAITS	= $(INCLUDE)/machine/$(MACH)/$(MMOD)_traits.h 
+MACH_TRAITS	= $(INCLUDE)/machine/$(MACH)/$(MMOD)_traits.h
 MEM_BASE	= $(call GETTK,MEM_BASE,$(MACH_TRAITS))
 MEM_TOP		= $(call GETTK,MEM_TOP,$(MACH_TRAITS))
 MEM_SIZE	= $(shell echo "(`printf "%d" $(MEM_TOP)` + 1 - `printf "%d" $(MEM_BASE)`) / 1024"|bc)
@@ -84,18 +84,18 @@
 #Machine specifics
 pc_CC_FLAGS             := -Wa,--32
 pc_AS_FLAGS             := --32
-pc_LD_FLAGS             := 
+pc_LD_FLAGS             :=
 pc_EMULATOR             = qemu-system-i386 -smp $(CPUS) -m $(MEM_SIZE)k -nographic -no-reboot -fda
 
-cortex_m_CC_FLAGS       := -mcpu=cortex-m3 -mthumb -mno-thumb-interwork -mfpu=fpa #-Wa,-mimplicit-it=arm -marm 
+cortex_m_CC_FLAGS       := -mcpu=cortex-m3 -mthumb -mno-thumb-interwork -mfpu=fpa #-Wa,-mimplicit-it=arm -marm
 cortex_m_AS_FLAGS       := -mcpu=cortex-m3 -mthumb -mfpu=fpa
-cortex_m_LD_FLAGS       := 
+cortex_m_LD_FLAGS       :=
 cortex_m_EMULATOR       = timeout --preserve-status --foreground 20s qemu-system-arm -cpu cortex-m3 -machine lm3s811evb -m $(MEM_SIZE)k -nographic -no-reboot -kernel
 
 atmega_CC_FLAGS         := -mmcu=atmega128 -Wno-inline
 atmega_AS_FLAGS         := -mmcu=atmega128
 atmega_LD_FLAGS         := -m avr5
-atmega_EMULATOR         = 
+atmega_EMULATOR         =
 
 $(MACH)_CODE_NAME       := .init
 $(MACH)_DATA_NAME       := .ctors
@@ -115,13 +115,13 @@
 MACH_EMULATOR           = $($(MACH)_EMULATOR)
 endif
 MACH_DEBUGGER           = $(TERM) gdb -ex "target remote:1234" -ex "set confirm off"
-ifneq ($(wildcard $(IMG)/$(MACH)_setup),) 
+ifneq ($(wildcard $(IMG)/$(MACH)_setup),)
 MACH_DEBUGGER           := $(MACH_DEBUGGER) -ex "add-symbol-file $(SRC)/setup/$(MACH)_setup $(SETUP_ADDR)"
 endif
-ifneq ($(wildcard $(IMG)/$(MACH)_init),) 
+ifneq ($(wildcard $(IMG)/$(MACH)_init),)
 MACH_DEBUGGER           := $(MACH_DEBUGGER) -ex "add-symbol-file $(SRC)/init/$(MACH)_init $(INIT_ADDR)"
 endif
-ifneq ($(wildcard $(IMG)/$(MACH)_system),) 
+ifneq ($(wildcard $(IMG)/$(MACH)_system),)
 MACH_DEBUGGER           := $(MACH_DEBUGGER) -ex "add-symbol-file $(SRC)/system/$(MACH)_system $(SYS_CODE_ADDR)"
 endif
 
@@ -128,7 +128,7 @@
 # Architecture specifics
 ARCH_LITTLE	:= little
 ARCH_BIG	:= big
-ARCH_TRAITS	= $(INCLUDE)/architecture/$(ARCH)/traits.h 
+ARCH_TRAITS	= $(INCLUDE)/architecture/$(ARCH)/traits.h
 ARCH_ENDIANESS	= $(ARCH_$(call GETTK,ENDIANESS,$(ARCH_TRAITS)))
 ARCH_WORD_SIZE	= $(call GETTK,WORD_SIZE,$(ARCH_TRAITS))
 ARCH_CLOCK	= $(call GETTK,CLOCK,$(ARCH_TRAITS))
@@ -140,7 +140,7 @@
 TCXX		:= g++ -c -ansi -fno-exceptions -std=c++0x
 TCXXFLAGS	:= -m32 -Wall -O2 -I$(INCLUDE)
 
-TCPP		:= gcc -E 
+TCPP		:= gcc -E
 TCPPFLAGS	:= -I$(INCLUDE)
 
 TLD		:= gcc
@@ -151,7 +151,7 @@
 ACXX		= $(BIN)/eposcc $(MACH_CC_FLAGS) -c -ansi -O2
 AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS) -c -ansi -O2
 ALD		= $(BIN)/eposcc --$(MODE) $(MACH_LD_FLAGS)
-ALDFLAGS	:= --gc-sections 
+ALDFLAGS	:= --gc-sections
 
 # Tools and flags to compile the system
 AR		= $(COMP_PREFIX)ar
@@ -160,7 +160,7 @@
 AS		= $(COMP_PREFIX)as
 ASFLAGS		= $(MACH_AS_FLAGS)
 
-CC		= $(COMP_PREFIX)gcc -ansi -c 
+CC		= $(COMP_PREFIX)gcc -ansi -c
 CCFLAGS		= $(MACH_CC_FLAGS) -O2 -nostdinc -Wall -Werror -I$(INCLUDE)
 CCLIB		= `$(CC) $(MACH_CC_FLAGS) -print-file-name=`
 
@@ -175,9 +175,9 @@
 
 DD		:= dd
 
-DEBUGGER	= $(MACH_DEBUGGER) 
+DEBUGGER	= $(MACH_DEBUGGER)
 
-EMULATOR	= $(MACH_EMULATOR) 
+EMULATOR	= $(MACH_EMULATOR)
 
 INSTALL		:= install
 
@@ -205,7 +205,7 @@
 
 TEE		:= tee
 
-TERM		:= xterm -e
+TERM		:= terminator -x
 
 TOUCH		:= touch
 
@@ -264,7 +264,7 @@
 		$(CLEAN) $<.tmp
 
 %.key: %.cc
-		$(EPOSANL) $< 
+		$(EPOSANL) $<
 
 %.key: %.c
 		$(EPOSANL) $<
Index: src/abstraction/alarm.cc
===================================================================
--- src/abstraction/alarm.cc	(revision 3599)
+++ src/abstraction/alarm.cc	(working copy)
@@ -14,7 +14,7 @@
 
 // Methods
 Alarm::Alarm(const Microsecond & time, Handler * handler, int times)
-: _ticks(ticks(time)), _handler(handler), _times(times), _link(this, _ticks)
+    : _ticks(ticks(time)), _handler(handler), _times(times), _link(this, _ticks)
 {
     lock();
 
Index: src/abstraction/semaphore_test.cc
===================================================================
--- src/abstraction/semaphore_test.cc	(revision 3599)
+++ src/abstraction/semaphore_test.cc	(working copy)
@@ -3,20 +3,19 @@
 #include <utility/ostream.h>
 #include <thread.h>
 #include <mutex.h>
-#include <semaphore.h>
+#include "semaphore.h"
 #include <alarm.h>
 #include <display.h>
 
-using namespace EPOS;
+//using namespace EPOS;
 
 const int iterations = 10;
 
 Mutex table;
-
-Thread * phil[5];
+S::Thread * phil[5];
 Semaphore * chopstick[5];
 
-OStream cout;
+S::OStream cout;
 
 int philosopher(int n, int l, int c)
 {
@@ -26,21 +25,21 @@
     for(int i = iterations; i > 0; i--) {
 
         table.lock();
-        Display::position(l, c);
+        S::Display::position(l, c);
         cout << "thinking";
         table.unlock();
 
-        Delay thinking(2000000);
+        S::Delay thinking(2000000);
 
         chopstick[first]->p();   // get first chopstick
         chopstick[second]->p();   // get second chopstick
 
         table.lock();
-        Display::position(l, c);
+        S::Display::position(l, c);
         cout << " eating ";
         table.unlock();
 
-        Delay eating(1000000);
+        S::Delay eating(1000000);
 
         chopstick[first]->v();   // release first chopstick
         chopstick[second]->v();   // release second chopstick
@@ -47,7 +46,7 @@
     }
 
     table.lock();
-    Display::position(l, c);
+    S::Display::position(l, c);
     cout << "  done  ";
     table.unlock();
 
@@ -57,41 +56,41 @@
 int main()
 {
     table.lock();
-    Display::clear();
-    Display::position(0, 0);
-    cout << "The Philosopher's Dinner:" << endl;
+    S::Display::clear();
+    S::Display::position(0, 0);
+    cout << "The Philosopher's Dinner:" << S::endl;
 
     for(int i = 0; i < 5; i++)
         chopstick[i] = new Semaphore;
 
-    phil[0] = new Thread(&philosopher, 0,  5, 32);
-    phil[1] = new Thread(&philosopher, 1, 10, 44);
-    phil[2] = new Thread(&philosopher, 2, 16, 39);
-    phil[3] = new Thread(&philosopher, 3, 16, 24);
-    phil[4] = new Thread(&philosopher, 4, 10, 20);
+    phil[0] = new S::Thread(&philosopher, 0,  5, 32);
+    phil[1] = new S::Thread(&philosopher, 1, 10, 44);
+    phil[2] = new S::Thread(&philosopher, 2, 16, 39);
+    phil[3] = new S::Thread(&philosopher, 3, 16, 24);
+    phil[4] = new S::Thread(&philosopher, 4, 10, 20);
 
-    cout << "Philosophers are alive and hungry!" << endl;
+    cout << "Philosophers are alive and hungry!" << EPOS::S::endl;
 
-    Display::position(7, 44);
+    S::Display::position(7, 44);
     cout << '/';
-    Display::position(13, 44);
+    S::Display::position(13, 44);
     cout << '\\';
-    Display::position(16, 35);
+    S::Display::position(16, 35);
     cout << '|';
-    Display::position(13, 27);
+    S::Display::position(13, 27);
     cout << '/';
-    Display::position(7, 27);
+    S::Display::position(7, 27);
     cout << '\\';
-    Display::position(19, 0);
+    S::Display::position(19, 0);
 
-    cout << "The dinner is served ..." << endl;
+    cout << "The dinner is served ..." << S::endl;
     table.unlock();
 
     for(int i = 0; i < 5; i++) {
         int ret = phil[i]->join();
         table.lock();
-        Display::position(20 + i, 0);
-        cout << "Philosopher " << i << " ate " << ret << " times " << endl;
+        S::Display::position(20 + i, 0);
+        cout << "Philosopher " << i << " ate " << ret << " times " << S::endl;
         table.unlock();
     }
 
@@ -100,7 +99,7 @@
     for(int i = 0; i < 5; i++)
         delete phil[i];
 
-    cout << "The end!" << endl;
+    cout << "The end!" << S::endl;
 
     return 0;
 }
Index: src/abstraction/task.cc
===================================================================
--- src/abstraction/task.cc	(revision 3599)
+++ src/abstraction/task.cc	(working copy)
@@ -10,7 +10,11 @@
 
 // Methods
 Task::Task(const Segment & code, const Segment & data)
-: _as (new (SYSTEM) Address_Space), _cs(const_cast<Segment *>(&code)), _ds(const_cast<Segment *>(&data)), _code(_as->attach(*_cs)), _data(_as->attach(*_ds))
+: _as (new (SYSTEM) Address_Space),
+  _cs(const_cast<Segment *>(&code)),
+  _ds(const_cast<Segment *>(&data)),
+  _code(_as->attach(*_cs)),
+  _data(_as->attach(*_ds))
 {
     db<Task>(TRC) << "Task(cs=" << _cs << ",ds=" << _ds << ") => " << this << endl;
 }
Index: src/abstraction/task_test.cc
===================================================================
--- src/abstraction/task_test.cc	(revision 3599)
+++ src/abstraction/task_test.cc	(working copy)
@@ -1,11 +1,11 @@
 // EPOS Task Test Program
 
-#include <utility/ostream.h>
-#include <alarm.h>
-#include <thread.h>
-#include <task.h>
+#include <stub/ostream.h>
+#include <stub/alarm.h>
+#include <stub/thread.h>
+#include <stub/task.h>
 
-using namespace EPOS;
+using namespace EPOS::APPLICATION;
 
 const int iterations = 10;
 
@@ -16,10 +16,12 @@
 Thread * b;
 Thread * m;
 
-OStream cout;
 
 int main()
 {
+    OStream cout;
+    Endl endl;
+
     cout << "Task test" << endl;
 
     m = Thread::self();
@@ -26,18 +28,19 @@
 
     cout << "I'll try to clone myself:" << endl;
 
-    const Task * task0 = Task::self();
+    Task * task0 = Task::self();
     Address_Space * as0 = task0->address_space();
-    cout << "My address space's page directory is located at " << as0->pd() << endl;
 
-    const Segment * cs0 = task0->code_segment();
-    CPU::Log_Addr code0 = task0->code();
+    cout << "My address space's page directory is located at " << "as0->pd()" << endl;
+
+    Segment * cs0 = task0->code_segment();
+    Log_Addr code0 = task0->code();
     cout << "My code segment is located at "
          << static_cast<void *>(code0)
          << " and it is " << cs0->size() << " bytes long" << endl;
 
-    const Segment * ds0 = task0->data_segment();
-    CPU::Log_Addr data0 = task0->data();
+    Segment * ds0 = task0->data_segment();
+    Log_Addr data0 = task0->data();
     cout << "My data segment is located at "
          << static_cast<void *>(data0)
          << " and it is " << ds0->size() << " bytes long" << endl;
@@ -44,12 +47,15 @@
 
     cout << "Creating and attaching segments:" << endl;
     Segment cs1(cs0->size());
-    CPU::Log_Addr code1 = as0->attach(cs1);
-    cout << "  code => " << code1 << " done!" << endl;
+    Log_Addr code1 = as0->attach(cs1);
+    cout << "  code => " << "code1" << " done!" << endl;
     Segment ds1(ds0->size());
-    CPU::Log_Addr data1 = as0->attach(ds1);
-    cout << "  data => " << data1 << " done!" << endl;
+    Log_Addr data1 = as0->attach(ds1);
+    cout << "  data => " << "data1 "<< " done!" << endl;
 
+    cout << "&code0=" << &code0 << endl;
+    cout << "&code1=" << &code1 << ", size=" << cs0->size() << endl;
+
     cout << "Copying segments:";
     memcpy(code1, code0, cs1.size());
     cout << " code => done!" << endl;
@@ -100,6 +106,9 @@
 
 int func_a(void)
 {
+    OStream cout;
+    Endl endl;
+
     for(int i = iterations; i > 0; i--) {
         for(int i = 0; i < 79; i++)
             cout << "a";
@@ -113,6 +122,9 @@
 
 int func_b(void)
 {
+    OStream cout;
+    Endl endl;
+
     for(int i = iterations; i > 0; i--) {
         for(int i = 0; i < 79; i++)
             cout << "b";
Index: src/abstraction/task_test_traits.h
===================================================================
--- src/abstraction/task_test_traits.h	(revision 3599)
+++ src/abstraction/task_test_traits.h	(working copy)
@@ -16,8 +16,8 @@
 
 template<> struct Traits<Build>
 {
-    enum {LIBRARY, BUILTIN};
-    static const unsigned int MODE = BUILTIN;
+    enum {LIBRARY, BUILTIN, KERNEL};
+    static const unsigned int MODE = KERNEL;
 
     enum {IA32};
     static const unsigned int ARCHITECTURE = IA32;
@@ -124,7 +124,7 @@
 {
     static const bool smp = Traits<System>::multicore;
 
-    typedef Scheduling_Criteria::RR Criterion;
+    typedef Scheduling_Criteria::FCFS Criterion;
     static const unsigned int QUANTUM = 10000; // us
 
     static const bool trace_idle = hysterically_debugged;
Index: src/abstraction/thread.cc
===================================================================
--- src/abstraction/thread.cc	(revision 3599)
+++ src/abstraction/thread.cc	(working copy)
@@ -23,8 +23,11 @@
                     << ",entry=" << entry
                     << ",state=" << _state
                     << ",priority=" << _link.rank()
-                    << ",stack={b=" << reinterpret_cast<void *>(_stack)
+                    << ",sytem_stack={b=" << reinterpret_cast<void *>(_stack)
                     << ",s=" << stack_size
+                    << "},user_phy=" << _user_stack->phy_address()
+                    << ",user_stack=" << reinterpret_cast<void*>(_user_stack)
+                    << ",s=" << _user_stack->size()
                     << "},context={b=" << _context
                     << "," << *_context << "}) => " << this << endl;
 
@@ -89,6 +92,7 @@
 
     unlock();
 
+    delete _user_stack;
     delete _stack;
 }
 
@@ -130,7 +134,7 @@
     } else
         unlock();
 
-    return *reinterpret_cast<int *>(_stack);
+    return *reinterpret_cast<int*>(_stack);
 }
 
 
@@ -212,7 +216,8 @@
 
     Thread * prev = running();
     _scheduler.remove(prev);
-    *reinterpret_cast<int *>(prev->_stack) = status;
+    int lad = prev->_user_stack->phy_address();
+    *reinterpret_cast<int *>(lad) = status;
     prev->_state = FINISHING;
 
     _thread_count--;
Index: src/abstraction/thread_init.cc
===================================================================
--- src/abstraction/thread_init.cc	(revision 3599)
+++ src/abstraction/thread_init.cc	(working copy)
@@ -17,8 +17,9 @@
     int (* entry)();
     if(Traits<Build>::MODE == Traits<Build>::LIBRARY)
         entry = reinterpret_cast<int (*)()>(__epos_app_entry);
-    else
+    else {
         entry = reinterpret_cast<int (*)()>(System::info()->lm.app_entry);
+    }
 
     db<Init, Thread>(TRC) << "Thread::init(entry=" << reinterpret_cast<void *>(entry) << ")" << endl;
 
@@ -36,7 +37,7 @@
         // Create the application's main thread
         // This must precede idle, thus avoiding implicit rescheduling
         first = new (SYSTEM) Thread(Configuration(RUNNING, MAIN, Traits<System>::STACK_SIZE), Task::_master, entry);
-        new (SYSTEM) Thread(Configuration(READY, IDLE, Traits<System>::STACK_SIZE), Task::_master, &idle);
+        new (SYSTEM) Thread(Configuration(READY, IDLE, Traits<System>::STACK_SIZE), Task::_master, true, &idle);
      } else {
         first = new (SYSTEM) Thread(Configuration(RUNNING, MAIN), entry);
         new (SYSTEM) Thread(Configuration(READY, IDLE), &idle);
Index: src/abstraction/thread_test.cc
===================================================================
--- src/abstraction/thread_test.cc	(revision 3599)
+++ src/abstraction/thread_test.cc	(working copy)
@@ -1,10 +1,10 @@
 // EPOS Thread Test Program
 
-#include <utility/ostream.h>
-#include <thread.h>
-#include <alarm.h>
+#include <stub/ostream.h>
+#include <stub/thread.h>
+#include <stub/alarm.h>
 
-using namespace EPOS;
+__USING_APPLICATION
 
 const int iterations = 100;
 
@@ -15,10 +15,12 @@
 Thread * b;
 Thread * m;
 
-OStream cout;
-
 int main()
 {
+
+    OStream cout;
+    OStream endl;
+
     cout << "Thread test" << endl;
 
     m = Thread::self();
@@ -46,6 +48,9 @@
 
 int func_a(void)
 {
+    OStream cout;
+    OStream endl;
+
     for(int i = iterations; i > 0; i--) {
         for(int i = 0; i < 79; i++)
             cout << "a";
@@ -58,6 +63,9 @@
 
 int func_b(void)
 {
+    OStream cout;
+    OStream endl;
+
     for(int i = iterations; i > 0; i--) {
         for(int i = 0; i < 79; i++)
             cout << "b";
Index: src/architecture/ia32/cpu.cc
===================================================================
--- src/architecture/ia32/cpu.cc	(revision 3599)
+++ src/architecture/ia32/cpu.cc	(working copy)
@@ -2,6 +2,7 @@
 
 #include <architecture/ia32/cpu.h>
 #include <thread.h>
+#include <system/memory_map.h>
 
 __BEGIN_SYS
 
@@ -34,27 +35,43 @@
 void IA32::Context::load() const volatile
 {
     // Pop the context pushed into the stack during thread creation to initialize the CPU's context
-    // Obs: POPA ignores the ESP saved by PUSHA. ESP is just normally incremented
-    ASM("       mov     4(%esp), %esp       # sp = this             \n"
-        "       popa                                                \n"
-        "       popf                                                \n");
+    // POPA ignores the SP saved by PUSHA. SP is just normally incremented
+    // IRET will pop FLAGS, CS, and IP
+    ASM("       mov     4(%esp), %esp         # sp = this           \n"
+        "       popa                                                \n");
+    ASM("       iret                                                \n");  // Chama "iret"
 }
 
 void IA32::switch_context(Context * volatile * o, Context * volatile n)
 {
-    // Save the previously running thread context ("o") into its stack 
-    // and updates the its _context attribute
-    // PUSHA saves an extra "esp" (which is always "this"), but saves several instruction fetches
-    ASM("	pushf                  		                \n"
-        "	pusha				                \n");
-    ASM("       mov     40(%esp), %eax          # old           \n"
-        "       mov     %esp, (%eax)                            \n");
+    // Recover the return address from the stack and
+    // save the previously running thread context ("o") into its stack
+    // PUSHA saves an extra SP (which is always "this"), but saves several instruction fetches
+    ASM("       pop     %esi                    # eip               \n"
+        "       pushf                                               \n"
+        "       push    %cs                                         \n"
+        "       push    %esi                    # eip               \n"
+        "       pusha                                               \n");
+    ASM("       mov     44(%esp), %eax          # old               \n"
+        "       mov     %esp, (%eax)                                \n");
 
-    // Restore the next thread context ("n") from its stack (and the user-level stack pointer, updating the dummy TSS)
-    ASM("	mov     44(%esp), %esp          # new	        \n");
-    ASM("	popa				                \n"
-        "	popf			                	\n");
-    ASM("       mov     %%esp, %0                               \n" : "=m"(Thread::running()->_context) : );
+
+    // Restore the next thread context ("n") from its stack
+    ASM("       mov     48(%esp), %esp          # new           \n");
+
+
+    Reg32 esp0 = 0;
+    ASM("mov %%esp, %0" : "=r"(esp0));
+
+    // will pop FLAGS, CS, and IP
+    ASM("       popa                                            \n");
+
+    TSS * tss0 = reinterpret_cast<TSS*>(Memory_Map<PC>::TSS0);
+    tss0->esp0 = esp0;
+
+    // Change context through the IRET
+    ASM("iret");
+
 }
 
 __END_SYS
Index: src/machine/pc/ic.cc
===================================================================
--- src/machine/pc/ic.cc	(revision 3599)
+++ src/machine/pc/ic.cc	(working copy)
@@ -3,8 +3,6 @@
 #include <machine/pc/ic.h>
 #include <machine.h>
 
-extern "C" { void _exit(int s); }
-
 __BEGIN_SYS
 
 // Class attributes
@@ -12,50 +10,6 @@
 PC_IC::Interrupt_Handler PC_IC::_int_vector[PC_IC::INTS];
 
 
-// Class methods
-void PC_IC::int_not(const Interrupt_Id & i)
-{
-    db<IC,Machine>(WRN) << "IC::int_not(i=" << i << ")" << endl;
-}
-
-void PC_IC::exc_not(const Interrupt_Id & i, Reg32 error, Reg32 eip, Reg32 cs, Reg32 eflags)
-{
-    db<IC,Machine>(WRN) << "IC::exc_not(i=" << i << ") => [err=" << hex << error << ",ctx={cs=" << cs << ",ip=" << eip << ",fl=" << eflags << "}]" << endl;
-    db<IC,Machine>(WRN) << "The running thread will now be terminated!" << endl;
-    _exit(-1);
-}
-
-void PC_IC::exc_pf(const Interrupt_Id & i, Reg32 error, Reg32 eip, Reg32 cs, Reg32 eflags)
-{  
-    db<IC,Machine>(WRN) << "IC::exc_pf(i=" << i << ") => [address=" << hex << CPU::cr2() << ",err={";
-    if(error & (1 << 0))
-        db<IC,Machine>(WRN) << "P";
-    if(error & (1 << 1))
-        db<IC,Machine>(WRN) << "W";
-    if(error & (1 << 2))
-        db<IC,Machine>(WRN) << "S";
-    if(error & (1 << 3))
-        db<IC,Machine>(WRN) << "R";
-    db<IC,Machine>(WRN) << "},ctx={cs=" << hex << cs << ",ip=" << eip << ",fl=" << eflags << "}]" << endl;
-
-    db<IC,Machine>(WRN) << "The running thread will now be terminated!" << endl;
-    _exit(-1);
-}
-
-void PC_IC::exc_gpf(const Interrupt_Id & i, Reg32 error, Reg32 eip, Reg32 cs, Reg32 eflags)
-{  
-    db<IC,Machine>(WRN) << "IC::exc_gpf(i=" << i << ")[err=" << hex << error << ",ctx={cs=" << (void *)cs << ",ip=" << (void *)eip << ",fl=" << (void *)eflags << "}]" << endl;
-    db<IC,Machine>(WRN) << "The running thread will now be terminated!" << endl;
-    _exit(-1);
-}
-
-void PC_IC::exc_fpu(const Interrupt_Id & i, Reg32 error, Reg32 eip, Reg32 cs, Reg32 eflags)
-{
-    db<IC,Machine>(WRN) << "IC::exc_fpu(i=" << i << ") => [err=" << hex << error << ",ctx={cs=" << cs << ",ip=" << eip << ",fl=" << eflags << "}]" << endl;
-    db<IC,Machine>(WRN) << "The running thread will now be terminated!" << endl;
-    _exit(-1);
-}
-
 // APIC class methods
 void APIC::ipi_init(volatile int * status)
 {
Index: src/machine/pc/ic_entry.cc
===================================================================
--- src/machine/pc/ic_entry.cc	(revision 3599)
+++ src/machine/pc/ic_entry.cc	(working copy)
@@ -1,7 +1,10 @@
 // EPOS PC Interrupt Dispatcher
 
 #include <machine/pc/ic.h>
+#include <stub/skeleton.h>
 
+extern "C" { void _exit(int s); }
+
 __BEGIN_SYS
 
 void PC_IC::entry()
@@ -778,15 +781,68 @@
         //        "        jmp        .GO         \n"
         //        "        .align 16              \n"
         //        "        movl        $255, %0   \n"
-        ".GO:    pushal                 \n"
-        : "=m"(id) : );
+        ".GO:    pushal                 \n" : "=m"(id) : );
 
     ASM("        pushl  %0              \n"
         "        call   *%1             \n"
         "        popl   %%eax           \n"
         "        popal                  \n"
-        "        iret                   \n"
-        : : "m"(id), "c"(dispatch));
+        "        iret                   \n" : : "m"(id), "c"(dispatch));
 };
 
+// Default logical handler
+void PC_IC::int_not(const Interrupt_Id & i)
+{
+    db<IC,Machine>(WRN) << "IC::int_not(i=" << i << ")" << endl;
+}
+
+// Exception and fault handlers
+void PC_IC::exc_not(Reg32 eip, Reg32 cs, Reg32 eflags, Reg32 error)
+{
+    db<IC,Machine>(WRN) << "IC::exc_not(cs=" << hex << cs << ",ip=" << reinterpret_cast<void *>(eip) << ",fl=" << eflags << ")" << endl;
+    db<IC,Machine>(WRN) << "The running thread will now be terminated!" << endl;
+    _exit(-1);
+}
+
+void PC_IC::exc_pf(Reg32 eip, Reg32 cs, Reg32 eflags, Reg32 error)
+{
+    db<IC,Machine>(WRN) << "IC::exc_pf[address=" << reinterpret_cast<void *>(CPU::cr2()) << "](cs=" << hex << cs << ",ip=" << reinterpret_cast<void *>(eip) << ",fl=" << eflags << ",err=";
+    if(error & (1 << 0))
+        db<IC,Machine>(WRN) << "P";
+    if(error & (1 << 1))
+        db<IC,Machine>(WRN) << "W";
+    if(error & (1 << 2))
+        db<IC,Machine>(WRN) << "S";
+    if(error & (1 << 3))
+        db<IC,Machine>(WRN) << "R";
+    db<IC,Machine>(WRN) << ")" << endl;
+
+    db<IC,Machine>(WRN) << "The running thread will now be terminated!" << endl;
+    _exit(-1);
+}
+
+void PC_IC::exc_gpf(Reg32 eip, Reg32 cs, Reg32 eflags, Reg32 error)
+{
+    db<IC,Machine>(WRN) << "IC::exc_gpf(cs=" << hex << cs << ",ip=" << reinterpret_cast<void *>(eip) << ",fl=" << eflags << ")" << endl;
+    db<IC,Machine>(WRN) << "The running thread will now be terminated!" << endl;
+    _exit(-1);
+}
+
+void PC_IC::exc_fpu(Reg32 eip, Reg32 cs, Reg32 eflags, Reg32 error)
+{
+    db<IC,Machine>(WRN) << "IC::exc_fpu(cs=" << hex << cs << ",ip=" << reinterpret_cast<void *>(eip) << ",fl=" << eflags << ")" << endl;
+    db<IC,Machine>(WRN) << "The running thread will now be terminated!" << endl;
+    _exit(-1);
+}
+
+void Skeleton::receive(){
+    ASM("pushal");
+    ASM("pushl %eax");
+    ASM("call *%0" : : "c"(Skeleton::call));
+    ASM("popl %eax");
+    ASM("popal");
+    ASM("iret");
+}
+
+
 __END_SYS
Index: src/machine/pc/ic_init.cc
===================================================================
--- src/machine/pc/ic_init.cc	(revision 3599)
+++ src/machine/pc/ic_init.cc	(working copy)
@@ -2,6 +2,7 @@
 
 #include <cpu.h>
 #include <ic.h>
+#include <stub/skeleton.h>
 
 __BEGIN_SYS
 
@@ -18,16 +19,20 @@
             idt[i] = CPU::IDT_Entry(CPU::SEL_SYS_CODE, Log_Addr(entry) + i * 16, CPU::SEG_IDT_ENTRY);
         else
             idt[i] = CPU::IDT_Entry(CPU::SEL_SYS_CODE, Log_Addr(entry) + CPU::EXC_LAST * 16, CPU::SEG_IDT_ENTRY);
-    
+
+    // Install some important exception handlers
+    idt[CPU::EXC_PF]     = CPU::IDT_Entry(CPU::SEL_SYS_CODE, Log_Addr(&exc_pf),  CPU::SEG_IDT_ENTRY);
+    idt[CPU::EXC_DOUBLE] = CPU::IDT_Entry(CPU::SEL_SYS_CODE, Log_Addr(&exc_pf),  CPU::SEG_IDT_ENTRY);
+    idt[CPU::EXC_GPF]    = CPU::IDT_Entry(CPU::SEL_SYS_CODE, Log_Addr(&exc_gpf), CPU::SEG_IDT_ENTRY);
+    idt[CPU::EXC_NODEV]  = CPU::IDT_Entry(CPU::SEL_SYS_CODE, Log_Addr(&exc_fpu), CPU::SEG_IDT_ENTRY);
+
     // Set all interrupt handlers to int_not()
     for(unsigned int i = 0; i < INTS; i++)
- 	_int_vector[i] = int_not;
+        _int_vector[i] = int_not;
 
-    // Reset some important exception handlers
-    _int_vector[CPU::EXC_PF] = reinterpret_cast<Interrupt_Handler>(exc_pf);
-    _int_vector[CPU::EXC_DOUBLE] = reinterpret_cast<Interrupt_Handler>(exc_pf);
-    _int_vector[CPU::EXC_GPF] = reinterpret_cast<Interrupt_Handler>(exc_gpf);
-    _int_vector[CPU::EXC_NODEV] = reinterpret_cast<Interrupt_Handler>(exc_fpu);
+    // Syscall
+    void (*entry_skeleton)() = reinterpret_cast<void (*)()>(Skeleton::receive);
+    idt[50] = CPU::IDT_Entry(CPU::SEL_SYS_CODE, Log_Addr(entry_skeleton), CPU::SEG_IDT_ENTRY);
 
     remap();
     disable();
Index: src/system/makefile
===================================================================
--- src/system/makefile	(revision 3599)
+++ src/system/makefile	(working copy)
@@ -21,8 +21,8 @@
 		$(INSTALL) $(MACH)_system $(IMG)
 		$(INSTALL) $(MACH)_application.o $(LIB)
 
-$(MACH)_system_library: system_scaffold.o application_scaffold.o
-		$(LD) $(LDFLAGS) -i system_scaffold.o -o $(MACH)_system.o
+$(MACH)_system_library: system_scaffold.o system_bindings.o application_scaffold.o
+		$(LD) $(LDFLAGS) -i system_scaffold.o system_bindings.o -o $(MACH)_system.o
 		$(INSTALL) application_scaffold.o $(MACH)_application.o
 
 $(MACH)_system_builtin: $(OBJS)
@@ -31,7 +31,7 @@
 		--section-start $(MACH_DATA_NAME)=$(SYS_DATA_ADDR) \
 		--entry=_init -o $(MACH)_system \
 		$(LIB)/$(ARCH)_crtbegin.o \
-		system_scaffold.o \
+		system_scaffold.o system_bindings.o \
 		$(LIB)/$(ARCH)_crtend.o \
 		--whole-archive \
 		-l$(LSYS) -l$(LMACH) -l$(LARCH) \
@@ -39,20 +39,20 @@
 		-l$(LUTIL) -lgcc
 		$(INSTALL) application_scaffold.o $(MACH)_application.o
 
-$(MACH)_system_kernel: $(OBJS) 
+$(MACH)_system_kernel: $(OBJS)
 		$(LD) $(LDFLAGS) -L$(CCLIB) --nmagic \
 		--section-start $(MACH_CODE_NAME)=$(SYS_CODE_ADDR) \
 		--section-start $(MACH_DATA_NAME)=$(SYS_DATA_ADDR) \
 		--entry=_init -o $(MACH)_system \
 		$(LIB)/$(ARCH)_crtbegin.o \
-		system_scaffold.o \
+		system_scaffold.o system_bindings.o \
 		$(LIB)/$(ARCH)_crtend.o \
 		--whole-archive \
 		-l$(LSYS) -l$(LMACH) -l$(LARCH) \
 		--no-whole-archive \
-		-l$(LUTIL) -lgcc 
-		$(LD) $(LDFLAGS) -i application_scaffold.o -o $(MACH)_application.o
-		
+		-l$(LUTIL) -lgcc
+		$(LD) $(LDFLAGS) -i application_scaffold.o -i application_bindings.o -o $(MACH)_application.o
+
 clean:
 		$(CLEAN) *.o *_system
 
Index: src/system/system_scaffold.cc
===================================================================
--- src/system/system_scaffold.cc	(revision 3599)
+++ src/system/system_scaffold.cc	(working copy)
@@ -35,16 +35,3 @@
 Heap * System::_heap;
 
 __END_SYS
-
-// Bindings
-__USING_SYS;
-extern "C" {
-    void _panic() { Machine::panic(); }
-    void _exit(int s) { Thread::exit(s); }
-    void _print(const char * s) { Display::puts(s); }
-
-    // LIBC Heritage
-    void __cxa_pure_virtual() {
-        db<void>(ERR) << "Pure Virtual method called!" << endl;
-    }
-}
Index: src/utility/ostream_test.cc
===================================================================
--- src/utility/ostream_test.cc	(revision 3599)
+++ src/utility/ostream_test.cc	(working copy)
@@ -12,6 +12,7 @@
     cout << "This is a char:\t\t\t" << 'A' << endl;
     cout << "This is a negative char:\t" << '\377' << endl;
     cout << "This is an unsigned char:\t" << 'A' << endl;
+    cout << "This is an int:\t\t\t" << 47 << endl;
     cout << "This is an int:\t\t\t" << (1 << sizeof(int) * 8 - 2) << endl
          << "\t\t\t\t" << hex << (1 << sizeof(int) * 8 - 2) << "(hex)" << endl
          << "\t\t\t\t" << dec << (1 << sizeof(int) * 8 - 2) << "(dec)" << endl
Index: tools/eposcc/eposcc
===================================================================
--- tools/eposcc/eposcc	(revision 3599)
+++ tools/eposcc/eposcc	(working copy)
@@ -34,7 +34,7 @@
 COMP_FLGS="-include $INC/utility/malloc.h"
 COMP_HDRS="$INC"
 if [ "$MODE" = "kernel" ] ; then
-COMP_FLGS="$COMP_FLGS -include $INC/framework/main.h"
+COMP_FLGS="$COMP_FLGS"
 fi
 
 C_COMPILER="$TOOLS_PREFIX""gcc"
@@ -107,7 +107,7 @@
 	output_file="$arg"
 	continue
     fi
-    case "$arg" in 
+    case "$arg" in
     -c)
 	all_args="$all_args $arg"
 	compile_flgs="$compile_flgs $arg"
@@ -160,7 +160,7 @@
    	    os_is_builtin=1
 	fi
 	;;
-    --library)	
+    --library)
 	if [ $os_is_kernel = 1 -o $os_is_builtin = 1 -o $os_is_linux = 1 ] ; then
 	    echo "--builtin, --kernel, --library and --linux cannot be used together!"
 	    exit -1
@@ -207,7 +207,7 @@
 	echo "   $my_name -c -O -Llibrary_path -Iheader_path -o foo foo.c"
 	exit 1
 	;;
-    *\"*) 
+    *\"*)
 	all_args="$all_args `echo $arg | sed 's/\"/\\\"/g'`"
 	compile_flgs="$compile_flgs `echo $arg | sed 's/\"/\\\"/g'`"
 	link_flgs="$link_flgs `echo $arg | sed 's/\"/\\\"/g'`"
@@ -315,7 +315,7 @@
 	LINK_OBJN=$LINK_OBJN_BUILTIN
 	LINK_LIBS=$LINK_LIBS_BUILTIN
 fi
-	
+
 linker=$LINKER
 link_flgs="$link_flgs $LINK_FLGS"
 link_objs="$LINK_OBJI $link_objs $LINK_OBJN"
@@ -383,7 +383,7 @@
     $do_echo $compiler $compile_flgs $compile_args $input_file
     $do_exec $compiler $compile_flgs $compile_args $input_file
     status=$?
-    if [ $status != 0 ] ; then 
+    if [ $status != 0 ] ; then
 	exit $status
     fi
 fi
