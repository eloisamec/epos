Index: app/philosophers_dinner.cc
===================================================================
--- app/philosophers_dinner.cc	(revision 3606)
+++ app/philosophers_dinner.cc	(working copy)
@@ -1 +1,107 @@
-link ../src/abstraction/semaphore_test.cc
\ No newline at end of file
+// EPOS Semaphore Abstraction Test Program
+
+#include <utility/ostream.h>
+#include <thread.h>
+#include <stub/mutex.h>
+#include <stub/semaphore.h>
+#include <stub/alarm.h>
+#include <stub/display.h>
+
+using namespace EPOS::APP;
+
+const int iterations = 10;
+
+Mutex table;
+
+EPOS::S::Thread * phil[5];
+Semaphore * chopstick[5];
+
+EPOS::S::OStream cout;
+Display display;
+int philosopher(int n, int l, int c)
+{
+	
+    int first = (n < 4)? n : 0;
+    int second = (n < 4)? n + 1 : 4;
+
+    for(int i = iterations; i > 0; i--) {
+
+        table.lock();
+        display.position(l, c);
+        cout << "thinking";
+        table.unlock();
+
+        Alarm::delay(2000000);
+
+        chopstick[first]->p();   // get first chopstick
+        chopstick[second]->p();   // get second chopstick
+
+        table.lock();
+        display.position(l, c);
+        cout << " eating ";
+        table.unlock();
+
+        Alarm::delay(1000000);
+
+        chopstick[first]->v();   // release first chopstick
+        chopstick[second]->v();   // release second chopstick
+    }
+
+    table.lock();
+    display.position(l, c);
+    cout << "  done  ";
+    table.unlock();
+
+    return iterations;
+}
+
+int main()
+{
+    table.lock();
+    display.clear();
+    display.position(0, 0);
+    cout << "The Philosopher's Dinner:" << EPOS::S::endl;
+
+    for(int i = 0; i < 5; i++)
+        chopstick[i] = new Semaphore;
+
+    phil[0] = new EPOS::S::Thread(&philosopher, 0,  5, 32);
+    phil[1] = new EPOS::S::Thread(&philosopher, 1, 10, 44);
+    phil[2] = new EPOS::S::Thread(&philosopher, 2, 16, 39);
+    phil[3] = new EPOS::S::Thread(&philosopher, 3, 16, 24);
+    phil[4] = new EPOS::S::Thread(&philosopher, 4, 10, 20);
+
+    cout << "Philosophers are alive and hungry!" << EPOS::S::endl;
+
+    display.position(7, 44);
+    cout << '/';
+    display.position(13, 44);
+    cout << '\\';
+    display.position(16, 35);
+    cout << '|';
+    display.position(13, 27);
+    cout << '/';
+    display.position(7, 27);
+    cout << '\\';
+    display.position(19, 0);
+
+    cout << "The dinner is served ..." << EPOS::S::endl;
+    table.unlock();
+
+    for(int i = 0; i < 5; i++) {
+        int ret = phil[i]->join();
+        table.lock();
+        display.position(20 + i, 0);
+        cout << "Philosopher " << i << " ate " << ret << " times " << EPOS::S::endl;
+        table.unlock();
+    }
+
+    for(int i = 0; i < 5; i++)
+        delete chopstick[i];
+    for(int i = 0; i < 5; i++)
+        delete phil[i];
+
+    cout << "The end!" << EPOS::S::endl;
+
+    return 0;
+}
Index: app/philosophers_dinner_traits.h
===================================================================
--- app/philosophers_dinner_traits.h	(revision 0)
+++ app/philosophers_dinner_traits.h	(working copy)
@@ -0,0 +1,161 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Global Configuration
+template<typename T>
+struct Traits
+{
+    static const bool enabled = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+};
+
+template<> struct Traits<Build>
+{
+    enum {LIBRARY, BUILTIN};
+    static const unsigned int MODE = BUILTIN;
+
+    enum {IA32};
+    static const unsigned int ARCHITECTURE = IA32;
+
+    enum {PC};
+    static const unsigned int MACHINE = PC;
+
+    enum {Legacy};
+    static const unsigned int MODEL = Legacy;
+
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // > 1 => NETWORKING
+};
+
+
+// Utilities
+template<> struct Traits<Debug>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<void>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<void>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<void>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<void>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<void>
+{
+};
+
+template<> struct Traits<Init>: public Traits<void>
+{
+};
+
+
+// Mediators
+template<> struct Traits<Serial_Display>: public Traits<void>
+{
+    static const bool enabled = true;
+    static const int COLUMNS = 80;
+    static const int LINES = 24;
+    static const int TAB_SIZE = 8;
+};
+
+__END_SYS
+
+#include __ARCH_TRAITS_H
+#include __MACH_CONFIG_H
+#include __MACH_TRAITS_H
+
+__BEGIN_SYS
+
+
+// Abstractions
+template<> struct Traits<Application>: public Traits<void>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<void>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = (mode != Traits<Build>::LIBRARY) || Traits<Scratchpad>::enabled;
+
+    enum {FOREVER = 0, SECOND = 1, MINUTE = 60, HOUR = 3600, DAY = 86400, WEEK = 604800, MONTH = 2592000, YEAR = 31536000};
+    static const unsigned long LIFE_SPAN = 1 * HOUR; // in seconds
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<void>
+{
+    static const bool smp = Traits<System>::multicore;
+
+    typedef Scheduling_Criteria::RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+
+    static const bool trace_idle = hysterically_debugged;
+};
+
+template<> struct Traits<Scheduler<Thread> >: public Traits<void>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+
+template<> struct Traits<Address_Space>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multiheap;
+};
+
+template<> struct Traits<Segment>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multiheap;
+};
+
+template<> struct Traits<Alarm>: public Traits<void>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+__END_SYS
+
+#endif

Property changes on: app/philosophers_dinner_traits.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: app/task_test
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: app/task_test
===================================================================
--- app/task_test	(revision 0)
+++ app/task_test	(working copy)

Property changes on: app/task_test
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: app/task_test.cc
===================================================================
--- app/task_test.cc	(revision 0)
+++ app/task_test.cc	(working copy)
@@ -0,0 +1,127 @@
+// EPOS Task Test Program
+
+#include <utility/ostream.h>
+#include <stub/alarm.h>
+#include <thread.h>
+#include <stub/task.h>
+
+using namespace EPOS::APP;
+
+const int iterations = 10;
+
+int func_a(void);
+int func_b(void);
+
+EPOS::S::Thread * a;
+EPOS::S::Thread * b;
+EPOS::S::Thread * m;
+
+EPOS::S::OStream cout;
+
+int main()
+{
+    cout << "Task test" << EPOS::S::endl;
+
+    m = EPOS::S::Thread::self();
+
+    cout << "I'll try to clone myself:" << EPOS::S::endl;
+
+    const Task * task0 = Task::self();
+    Address_Space * as0 = task0->address_space();
+    cout << "My address space's page directory is located at " << as0->pd() << EPOS::S::endl;
+
+    const Segment * cs0 = task0->code_segment();
+    CPU::Log_Addr code0 = task0->code();
+    cout << "My code segment is located at "
+         << static_cast<void *>(code0)
+         << " and it is " << cs0->size() << " bytes long" << EPOS::S::endl;
+
+    const Segment * ds0 = task0->data_segment();
+    CPU::Log_Addr data0 = task0->data();
+    cout << "My data segment is located at "
+         << static_cast<void *>(data0)
+         << " and it is " << ds0->size() << " bytes long" << EPOS::S::endl;
+
+    cout << "Creating and attaching segments:" << EPOS::S::endl;
+    Segment cs1(cs0->size());
+    CPU::Log_Addr code1 = as0->attach(cs1);
+    cout << "  code => " << code1 << " done!" << EPOS::S::endl;
+    Segment ds1(ds0->size());
+    CPU::Log_Addr data1 = as0->attach(ds1);
+    cout << "  data => " << data1 << " done!" << EPOS::S::endl;
+
+    cout << "Copying segments:";
+    memcpy(code1, code0, cs1.size());
+    cout << " code => done!" << EPOS::S::endl;
+    memcpy(data1, data0, ds1.size());
+    cout << " data => done!" << EPOS::S::endl;
+
+    cout << "Detaching segments:";
+    as0->detach(cs1);
+    as0->detach(ds1);
+    cout << " done!" << EPOS::S::endl;
+
+    cout << "Creating the clone task:";
+    Task * task1 = new Task(cs1, ds1);
+    cout << " done!" << EPOS::S::endl;
+
+    cout << "Creating a thread over the cloned task:";
+    a = new Thread(task1, &func_a);
+    cout << " done!" << EPOS::S::endl;
+
+    cout << "Creating a thread over the main task:";
+    b = new Thread(&func_b);
+    cout << " done!" << EPOS::S::endl;
+
+    cout << "I'll now suspend my self to see the other threads running:" << EPOS::S::endl;
+    m->suspend();
+
+    cout << "Both threads are now done and have suspended themselves. I'll now wait for 1 second and then wake them up so they can exit ..." << EPOS::S::endl;
+
+    Alarm::delay(1000000);
+
+    a->resume();
+    b->resume();
+
+    int status_a = a->join();
+    int status_b = b->join();
+
+    cout << "Thread A exited with status " << status_a << " and thread B exited with status " << status_b << "." << EPOS::S::endl;
+
+    delete a;
+    delete b;
+    delete task1;
+
+    cout << "I'm also done, bye!" << EPOS::S::endl;
+
+    return 0;
+}
+
+
+int func_a(void)
+{
+    for(int i = iterations; i > 0; i--) {
+        for(int i = 0; i < 79; i++)
+            cout << "a";
+        cout << EPOS::S::endl;
+        Thread::yield();
+    }
+
+    Thread::self()->suspend();
+    return 'A';
+}
+
+int func_b(void)
+{
+    for(int i = iterations; i > 0; i--) {
+        for(int i = 0; i < 79; i++)
+            cout << "b";
+        cout << EPOS::S::endl;
+        Thread::yield();
+    }
+
+    m->resume();
+
+    Thread::self()->suspend();
+    return 'B';
+}
Index: app/task_test_traits.h
===================================================================
--- app/task_test_traits.h	(revision 0)
+++ app/task_test_traits.h	(working copy)
@@ -0,0 +1,161 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Global Configuration
+template<typename T>
+struct Traits
+{
+    static const bool enabled = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+};
+
+template<> struct Traits<Build>
+{
+    enum {LIBRARY, BUILTIN};
+    static const unsigned int MODE = BUILTIN;
+
+    enum {IA32};
+    static const unsigned int ARCHITECTURE = IA32;
+
+    enum {PC};
+    static const unsigned int MACHINE = PC;
+
+    enum {Legacy};
+    static const unsigned int MODEL = Legacy;
+
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // > 1 => NETWORKING
+};
+
+
+// Utilities
+template<> struct Traits<Debug>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<void>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<void>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<void>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<void>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<void>
+{
+};
+
+template<> struct Traits<Init>: public Traits<void>
+{
+};
+
+
+// Mediators
+template<> struct Traits<Serial_Display>: public Traits<void>
+{
+    static const bool enabled = true;
+    static const int COLUMNS = 80;
+    static const int LINES = 24;
+    static const int TAB_SIZE = 8;
+};
+
+__END_SYS
+
+#include __ARCH_TRAITS_H
+#include __MACH_CONFIG_H
+#include __MACH_TRAITS_H
+
+__BEGIN_SYS
+
+
+// Abstractions
+template<> struct Traits<Application>: public Traits<void>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<void>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = (mode != Traits<Build>::LIBRARY) || Traits<Scratchpad>::enabled;
+
+    enum {FOREVER = 0, SECOND = 1, MINUTE = 60, HOUR = 3600, DAY = 86400, WEEK = 604800, MONTH = 2592000, YEAR = 31536000};
+    static const unsigned long LIFE_SPAN = 1 * HOUR; // in seconds
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<void>
+{
+    static const bool smp = Traits<System>::multicore;
+
+    typedef Scheduling_Criteria::RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+
+    static const bool trace_idle = hysterically_debugged;
+};
+
+template<> struct Traits<Scheduler<Thread> >: public Traits<void>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+
+template<> struct Traits<Address_Space>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multiheap;
+};
+
+template<> struct Traits<Segment>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multiheap;
+};
+
+template<> struct Traits<Alarm>: public Traits<void>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+__END_SYS
+
+#endif

Property changes on: app/task_test_traits.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: app/test
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: app/test
===================================================================
--- app/test	(revision 0)
+++ app/test	(working copy)

Property changes on: app/test
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: app/test.cc
===================================================================
--- app/test.cc	(revision 0)
+++ app/test.cc	(working copy)
@@ -0,0 +1,93 @@
+#include <stub/semaphore.h>
+//#include <stub/alarm.h>
+//#include <stub/condition.h>
+//#include <stub/address_space.h>
+//#include <stub/segment.h>
+//#include <stub/mutex.h>
+//#include <stub/task.h>
+//#include <stub/ostream.h>
+//#include <stub/thread.h>
+
+using namespace EPOS::APP;
+
+int fn(int,int,int,int);
+void fun_void(void);
+
+int main()
+{
+    EPOS::S::OStream cout;
+
+
+    //Address_Space address;
+   // cout << "Addres Space=" << &address;
+
+    //Segment segment1 (16*1024);
+    //cout << ">>>>>>>>>>>>>>>>>>>>>Segment 1 = " << (void*) &segment1;
+//    cout << "Stub Test!" << endl;
+
+    //Log_Addr log_addr = address.attach(segment1);
+    //address.detach(segment1);
+
+    //Segment segment2 (log_addr, 16*1024);
+    //cout << "Segment2=" << &segment2;
+
+    //address.attach(segment2, log_addr);
+
+   // cout << "Fuuuuusão: " << (char)(fn (65, 1, 1, 1)) << endl;
+
+    //Thread t(&fn, 60,2,3,1);
+
+   // cout << ">>> Retorno do JOIN: [[" << (char) t.join() << "]]" << endl;
+
+//    cout << "KReat0Rs";
+
+
+//    Function_Handler fh(&fun_void);
+//    cout << "Function Handler=" << &fh;
+
+//    Alarm alarm(1000000,&fh,1);
+//    cout << "Alarm=" << &alarm;
+
+//    Condition condition;
+//    cout << "Condition=" << &condition;
+
+//    Condition_Handler ch(&condition);
+//    cout << "Condition Handler=" << &ch;
+
+//    Mutex mutex;
+//    cout << "Mutex=" << &mutex;
+
+//    Mutex_Handler mh(&mutex);
+//    cout << "Mutex Handler=" << &mh;
+
+
+    Semaphore semaphore;
+    cout << "Semaphore=" << &semaphore;
+
+//    Semaphore_Handler sh(&semaphore);
+//    cout << "Semaphore Handler=" << &sh;
+
+//    //Task task(segment1, segment2);
+
+//    Task *task = Task::self();
+//    cout << "Task=" << task;
+
+//    Alarm::delay(2000000);
+
+    cout << "BYE";
+    return 0;
+}
+
+int fn(int a, int b, int c, int d){
+    EPOS::S::OStream cout;
+    int e = a + b + c + d;
+    cout << "Fn = {" << ((char) e) << "}" << "\n";
+    return e;
+}
+
+
+//void fun_void(){
+//    OStream cout;
+//    Endl endl;
+//    cout << "Oi sou uma função que não retorna nada Emoticon smile " << endl;
+//}
\ No newline at end of file
Index: app/test_traits.h
===================================================================
--- app/test_traits.h	(revision 0)
+++ app/test_traits.h	(working copy)
@@ -0,0 +1,161 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Global Configuration
+template<typename T>
+struct Traits
+{
+    static const bool enabled = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+};
+
+template<> struct Traits<Build>
+{
+    enum {LIBRARY, BUILTIN};
+    static const unsigned int MODE = BUILTIN;
+
+    enum {IA32};
+    static const unsigned int ARCHITECTURE = IA32;
+
+    enum {PC};
+    static const unsigned int MACHINE = PC;
+
+    enum {Legacy};
+    static const unsigned int MODEL = Legacy;
+
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // > 1 => NETWORKING
+};
+
+
+// Utilities
+template<> struct Traits<Debug>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<void>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<void>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<void>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<void>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<void>
+{
+};
+
+template<> struct Traits<Init>: public Traits<void>
+{
+};
+
+
+// Mediators
+template<> struct Traits<Serial_Display>: public Traits<void>
+{
+    static const bool enabled = true;
+    static const int COLUMNS = 80;
+    static const int LINES = 24;
+    static const int TAB_SIZE = 8;
+};
+
+__END_SYS
+
+#include __ARCH_TRAITS_H
+#include __MACH_CONFIG_H
+#include __MACH_TRAITS_H
+
+__BEGIN_SYS
+
+
+// Abstractions
+template<> struct Traits<Application>: public Traits<void>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<void>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = (mode != Traits<Build>::LIBRARY) || Traits<Scratchpad>::enabled;
+
+    enum {FOREVER = 0, SECOND = 1, MINUTE = 60, HOUR = 3600, DAY = 86400, WEEK = 604800, MONTH = 2592000, YEAR = 31536000};
+    static const unsigned long LIFE_SPAN = 1 * HOUR; // in seconds
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<void>
+{
+    static const bool smp = Traits<System>::multicore;
+
+    typedef Scheduling_Criteria::RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+
+    static const bool trace_idle = hysterically_debugged;
+};
+
+template<> struct Traits<Scheduler<Thread> >: public Traits<void>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+
+template<> struct Traits<Address_Space>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multiheap;
+};
+
+template<> struct Traits<Segment>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multiheap;
+};
+
+template<> struct Traits<Alarm>: public Traits<void>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<void>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+__END_SYS
+
+#endif

Property changes on: app/test_traits.h
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: bin/eposcc
===================================================================
--- bin/eposcc	(revision 0)
+++ bin/eposcc	(working copy)
@@ -0,0 +1,400 @@
+#!/bin/sh
+#=========================================================================
+# Script to compile and link EPOS applications
+#=========================================================================
+
+#=========================================================================
+# PATHS
+#=========================================================================
+EPOS=/home/maria.eloisa/epos
+TMP=/tmp
+INC=$EPOS/include
+SRC=$EPOS/src
+APP=$EPOS/app
+BIN=$EPOS/bin
+LIB=$EPOS/lib
+IMG=$EPOS/img
+ETC=$EPOS/etc
+DOC=$EPOS/doc
+
+#=========================================================================
+# CONFIGURATION
+#=========================================================================
+. $ETC/eposcc.conf
+
+#=========================================================================
+# CUSTOMIZABLE DEFINITIONS
+#=========================================================================
+ANALYZER=eposanl
+ANL_FLGS="-u"
+ANL_COMP_FLGS="-DANALYZE"
+
+CONFIGURATOR=eposcfg
+
+COMP_FLGS="-include $INC/utility/malloc.h"
+COMP_HDRS="$INC"
+if [ "$MODE" = "kernel" ] ; then
+COMP_FLGS="$COMP_FLGS -include $INC/framework/main.h"
+fi
+
+C_COMPILER="$TOOLS_PREFIX""gcc"
+C_COMP_FLGS="$MACH_CC_FLAGS"
+C_COMP_HDRS=
+C_LINK_FLGS="$MACH_LD_FLAGS"
+C_LINK_OBJS=
+C_LINK_LIBS=
+
+CPP_COMPILER="$TOOLS_PREFIX""g++"
+CPP_COMP_FLGS="--no-exceptions --no-rtti --no-use-cxa-atexit -std=c++0x"
+CPP_COMP_HDRS=
+CPP_LINK_FLGS=
+CPP_LINK_OBJS=
+CPP_LINK_LIBS=
+
+F77_COMPILER="$TOOLS_PREFIX""g77"
+F77_COMP_FLGS=
+F77_COMP_HDRS=
+F77_LINK_FLGS=
+F77_LINK_OBJS=
+F77_LINK_LIBS="f2c"
+
+LINKER="$TOOLS_PREFIX""ld"
+
+LINKER_LIBRARY=$LINKER
+LINK_FLGS_LIBRARY="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --nmagic --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
+LINK_OBJI_LIBRARY="$LIB/$ARCH""_crt0.o $LIB/$ARCH""_crtbegin.o $LIB/$MACH""_init_first.o $LIB/$MACH""_init_application.o $LIB/$MACH""_application.o"
+LINK_OBJN_LIBRARY="$LIB/$MACH""_init_system.o $LIB/$MACH""_system.o $LIB/$ARCH""_crtend.o"
+LINK_LIBS_LIBRARY="util_$ARCH init_$ARCH sys_$ARCH mach_$ARCH arch_$ARCH util_$ARCH gcc"
+
+LINKER_BUILTIN=$LINKER
+LINK_FLGS_BUILTIN="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --nmagic --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
+LINK_OBJI_BUILTIN="$LIB/$ARCH""_crt0.o $LIB/$ARCH""_crtbegin.o $LIB/$MACH""_init_application.o  $LIB/$MACH""_application.o"
+LINK_OBJN_BUILTIN="$LIB/$ARCH""_crtend.o -R$SRC/system/$MACH""_system"
+LINK_LIBS_BUILTIN="util_$ARCH gcc"
+
+LINKER_KERNEL=$LINKER
+LINK_FLGS_KERNEL="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --nmagic --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
+LINK_OBJI_KERNEL="$LIB/$ARCH""_crt0.o $LIB/$ARCH""_crtbegin.o $LIB/$MACH""_init_application.o  $LIB/$MACH""_application.o"
+LINK_OBJN_KERNEL="$LIB/$ARCH""_crtend.o"
+LINK_LIBS_KERNEL="util_$ARCH arch_$ARCH gcc"
+
+#=========================================================================
+# VARIABLES
+#=========================================================================
+do_exec=eval
+do_echo=:
+need_link=1
+need_compile=0
+need_trace=0
+need_analyze=0
+only_analyze=0
+os_is_library=0
+os_is_builtin=0
+os_is_kernel=0
+os_is_linux=0
+language=C
+getting_output_file=0
+has_dash_c=0
+my_name=`basename $0`
+status=0
+
+#=========================================================================
+# ARGUMENT PARSING
+#=========================================================================
+for arg in "$@" ; do
+    if [ $getting_output_file = 1 ] ; then
+	getting_output_file=0
+	output_file="$arg"
+	continue
+    fi
+    case "$arg" in 
+    -c)
+	all_args="$all_args $arg"
+	compile_flgs="$compile_flgs $arg"
+	need_link=0
+	need_compile=1
+	has_dash_c=1
+	;;
+    -E)
+	all_args="$all_args $arg"
+	compile_flgs="$compile_flgs $arg"
+	need_link=0
+	has_dash_c=1
+	need_compile=1
+	;;
+    -S)
+	all_args="$all_args $arg"
+	compile_flgs="$compile_flgs $arg"
+	need_link=0
+	has_dash_c=1
+	need_compile=1
+	;;
+    -o)
+	all_args="$all_args $arg"
+	getting_output_file=1
+	;;
+    -l*)
+	libs="$libs $arg"
+	link_args="$link_args $arg"
+	all_args="$all_args $arg"
+	;;
+    --analyze)
+	need_analyze=1
+	only_analyze=1
+	need_link=0
+	need_compile=0
+	;;
+    --linux)
+	if [ $os_is_kernel = 1 -o $os_is_library = 1 -o $os_is_builtin = 1 ] ; then
+           echo "--builtin, --kernel, --library and --linux cannot be used together!"
+           exit -1
+	else
+	   os_is_linux=1
+	fi
+	;;
+    --builtin)
+	if [ $os_is_kernel = 1 -o $os_is_library = 1 -o $os_is_linux = 1 ] ; then
+	    echo "--builtin, --kernel, --library and --linux cannot be used together!"
+	    exit -1
+	else
+   	    os_is_builtin=1
+	fi
+	;;
+    --library)	
+	if [ $os_is_kernel = 1 -o $os_is_builtin = 1 -o $os_is_linux = 1 ] ; then
+	    echo "--builtin, --kernel, --library and --linux cannot be used together!"
+	    exit -1
+	else
+   	    os_is_library=1
+	fi
+	;;
+    --kernel)
+	if [ $os_is_library = 1 -o $os_is_builtin = 1 -o $os_is_linux = 1 ] ; then
+	    echo "--builtin, --kernel, --library and --linux cannot be used together!"
+	    exit -1
+	else
+	    os_is_kernel=1
+	fi
+	;;
+    --trace)
+	need_trace=1
+	;;
+    --echo)
+	do_echo=echo
+	;;
+    --show)
+	do_echo=echo
+	do_exec=:
+	;;
+    --help)
+	echo "This is a script to compile and/or link EPOS programs"
+	echo "written in C, C++ or Fortran."
+	echo
+	echo "In addition to your compiler options, the following is supported"
+	echo "  --analyze analyze application requirements"
+	echo "  --library EPOS is a library to be linked with the application"
+	echo "  --builtin EPOS is built-in the application"
+	echo "  --kernel  EPOS is a microkernel"
+	echo "  --linux   EPOS is guest at Linux"
+	echo "  --trace   instruct EPOS to generate traces"
+	echo "  --show    show commands without issuing them"
+	echo "  --help    print this help"
+	echo "  --echo    show what this script is doing"
+	echo
+	echo "This script should be used just like your usual compiler, e.g.:"
+	echo "   $my_name -c foo.cc"
+	echo "   $my_name -o foo foo.o"
+	echo "   $my_name -c -O -Llibrary_path -Iheader_path -o foo foo.c"
+	exit 1
+	;;
+    *\"*) 
+	all_args="$all_args `echo $arg | sed 's/\"/\\\"/g'`"
+	compile_flgs="$compile_flgs `echo $arg | sed 's/\"/\\\"/g'`"
+	link_flgs="$link_flgs `echo $arg | sed 's/\"/\\\"/g'`"
+	;;
+    *)
+	all_args="$all_args $arg"
+	if [ -s "$arg" ] ; then
+	    ext=`expr "$arg" : '.*\(\..*\)'`
+	    if [ "$ext" = ".c" ] ; then
+		language="C"
+	        need_compile=1
+	        input_file="$arg"
+		key_file="`basename $arg $ext`.key"
+	        link_objs="$link_objs `basename $arg $ext`.o"
+	    elif [ "$ext" = ".f" ] ; then
+		language="F77"
+	        need_compile=1
+	        input_file="$arg"
+		key_file="`basename $arg $ext`.key"
+	        link_objs="$link_objs `basename $arg $ext`.o"
+	    elif [ "$ext" = ".C" -o "$ext" = ".cpp" -o "$ext" = ".cc" ] ; then
+		language="CPP"
+	        need_compile=1
+	        input_file="$arg"
+		key_file="`basename $arg $ext`.key"
+	        link_objs="$link_objs `basename $arg $ext`.o"
+	    elif [ "$ext" = ".o" ] ; then
+		if [ $need_compile = 1 ] ; then
+	            compile_args="$compile_args $arg"
+                else
+	            need_link=1
+	            link_objs="$link_objs $arg"
+                fi
+	    else
+	        compile_args="$compile_args $arg"
+	        link_args="$link_args $arg"
+	    fi
+	else
+            compile_flgs="$compile_flgs $arg"
+	    link_flgs="$link_flgs $arg"
+	fi
+	;;
+    esac
+done
+
+#=========================================================================
+# COMMAND ISSUING
+#=========================================================================
+if [ "$language" = "F77" ] ; then
+    compiler=$F77_COMPILER
+    compile_flgs="$compile_flgs $F77_COMP_FLGS"
+    for hdr in $F77_COMP_HDRS ; do
+	compile_flgs="$compile_flgs -I$hdr"
+    done
+    link_flgs="$link_flgs $F77_LINK_FLGS"
+    link_objs="$F77_LINK_OBJS $link_objs"
+    for lib in $F77_LINK_LIBS ; do
+	link_libs="$link_libs -l$lib"
+    done
+elif [ "$language" = "CPP" ] ; then
+    compiler=$CPP_COMPILER
+    compile_flgs="$compile_flgs $CPP_COMP_FLGS"
+    for hdr in $CPP_COMP_HDRS ; do
+	compile_flgs="$compile_flgs -I$hdr"
+    done
+    link_flgs="$link_flgs $CPP_LINK_FLGS"
+    link_objs="$CPP_LINK_OBJS $link_objs"
+    for lib in $CPP_LINK_LIBS ; do
+	link_libs="$link_libs -l$lib"
+    done
+else
+    compiler=$C_COMPILER
+    compile_flgs="$compile_flgs $C_COMP_FLGS"
+    for hdr in $C_COMP_HDRS ; do
+	compile_flgs="$compile_flgs -I$hdr"
+    done
+    link_flgs="$link_flgs $C_LINK_FLGS"
+    link_objs="$C_LINK_OBJS $link_objs"
+    for lib in $C_LINK_LIBS ; do
+	link_libs="$link_libs -l$lib"
+    done
+fi
+
+compile_flgs="$compile_flgs $COMP_FLGS"
+for hdr in $COMP_HDRS ; do
+    compile_flgs="$compile_flgs -I$hdr"
+done
+
+if [ $os_is_kernel = 1 ] ; then
+        LINKER=$LINKER_KERNEL
+	LINK_FLGS=$LINK_FLGS_KERNEL
+	LINK_OBJI=$LINK_OBJI_KERNEL
+	LINK_OBJN=$LINK_OBJN_KERNEL
+	LINK_LIBS=$LINK_LIBS_KERNEL
+    elif [ $os_is_library = 1 ] ; then
+	LINKER=$LINKER_LIBRARY
+	LINK_FLGS=$LINK_FLGS_LIBRARY
+	LINK_OBJI=$LINK_OBJI_LIBRARY
+	LINK_OBJN=$LINK_OBJN_LIBRARY
+	LINK_LIBS=$LINK_LIBS_LIBRARY
+    elif [ $os_is_builtin = 1 ] ; then
+	LINKER=$LINKER_BUILTIN
+	LINK_FLGS=$LINK_FLGS_BUILTIN
+	LINK_OBJI=$LINK_OBJI_BUILTIN
+	LINK_OBJN=$LINK_OBJN_BUILTIN
+	LINK_LIBS=$LINK_LIBS_BUILTIN
+fi
+	
+linker=$LINKER
+link_flgs="$link_flgs $LINK_FLGS"
+link_objs="$LINK_OBJI $link_objs $LINK_OBJN"
+for lib in $LINK_LIBS ; do
+  link_libs="$link_libs -l$lib"
+done
+
+if [ $need_compile = 1 -a ! -f "$key_file" ] ; then
+    need_analyze=1
+fi
+
+# disabled for EPOS
+if [ $need_analyze = 5 ] ; then
+    analyze_flgs=$compile_flgs
+
+    if [ $has_dash_c = 0 ] ; then
+	analyze_flgs="-c $analyze_flgs"
+    fi
+    tmp_file="$TMP/epos`date +%Y%m%d%H%M%S`"
+    analyze_flgs="$analyze_flgs $ANL_COMP_FLGS"
+    analyze_flgs="$analyze_flgs -o $tmp_file.o"
+    $do_echo $compiler $analyze_flgs $analyze_args $input_file
+    $do_exec $compiler $analyze_flgs $analyze_args $input_file
+    status=$?
+    if [ $status != 0 ] ; then
+	$do_echo rm -f "$tmp_file.*"
+	$do_exec rm -f "$tmp_file.*"
+	exit $status
+    fi
+
+    $do_echo $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
+    $do_exec $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
+    status=$?
+    if [ $status != 0 ] ; then
+	$do_echo rm -f "$tmp_file.*"
+	$do_exec rm -f "$tmp_file.*"
+	exit $status
+    fi
+
+    if [ $only_analyze = 1 -a -n "$output_file" ] ; then
+	configurator_output_file=$output_file
+    else
+	configurator_output_file=$key_file
+    fi
+    $do_echo $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
+    $do_exec $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
+
+    status=$?
+    $do_echo rm -f "$tmp_file.*"
+    $do_exec rm -f "$tmp_file.*"
+
+    if [ $only_analyze = 1 ] ; then
+	exit $status
+    fi
+fi
+
+if [ $need_compile = 1 ] ; then
+    if [ $has_dash_c = 0 ] ; then
+	compile_flgs="-c $compile_flgs"
+    fi
+    if [ $has_dash_c = 1 -a -n "$output_file" ] ; then
+	compile_flgs="$compile_flgs -o $output_file"
+    fi
+    compile_flgs="$compile_flgs -DCONFIG_KEYS=\\\"$PWD/$key_file\\\""
+    $do_echo $compiler $compile_flgs $compile_args $input_file
+    $do_exec $compiler $compile_flgs $compile_args $input_file
+    status=$?
+    if [ $status != 0 ] ; then 
+	exit $status
+    fi
+fi
+
+if [ $need_link = 1 ] ; then
+    if [ -n "$output_file" ] ; then
+	link_flgs="$link_flgs -o $output_file"
+    fi
+    $do_echo "$linker $link_flgs $link_objs $link_args $link_libs"
+    $do_exec $linker $link_flgs $link_objs $link_args $link_libs
+    status=$?
+fi
+
+exit $status

Property changes on: bin/eposcc
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: bin/eposmkbi
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: bin/eposmkbi
===================================================================
--- bin/eposmkbi	(revision 0)
+++ bin/eposmkbi	(working copy)

Property changes on: bin/eposmkbi
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: changes.diff
===================================================================
--- changes.diff	(revision 0)
+++ changes.diff	(working copy)
@@ -0,0 +1,1333 @@
+Index: app/philosophers_dinner.cc
+===================================================================
+--- app/philosophers_dinner.cc	(revision 3606)
++++ app/philosophers_dinner.cc	(working copy)
+@@ -1 +1,107 @@
+-link ../src/abstraction/semaphore_test.cc
+\ No newline at end of file
++// EPOS Semaphore Abstraction Test Program
++
++#include <utility/ostream.h>
++#include <thread.h>
++#include <stub/mutex.h>
++#include <stub/semaphore.h>
++#include <stub/alarm.h>
++#include <stub/display.h>
++
++using namespace EPOS::APP;
++
++const int iterations = 10;
++
++Mutex table;
++
++EPOS::S::Thread * phil[5];
++Semaphore * chopstick[5];
++
++EPOS::S::OStream cout;
++Display display;
++int philosopher(int n, int l, int c)
++{
++	
++    int first = (n < 4)? n : 0;
++    int second = (n < 4)? n + 1 : 4;
++
++    for(int i = iterations; i > 0; i--) {
++
++        table.lock();
++        display.position(l, c);
++        cout << "thinking";
++        table.unlock();
++
++        Alarm::delay(2000000);
++
++        chopstick[first]->p();   // get first chopstick
++        chopstick[second]->p();   // get second chopstick
++
++        table.lock();
++        display.position(l, c);
++        cout << " eating ";
++        table.unlock();
++
++        Alarm::delay(1000000);
++
++        chopstick[first]->v();   // release first chopstick
++        chopstick[second]->v();   // release second chopstick
++    }
++
++    table.lock();
++    display.position(l, c);
++    cout << "  done  ";
++    table.unlock();
++
++    return iterations;
++}
++
++int main()
++{
++    table.lock();
++    display.clear();
++    display.position(0, 0);
++    cout << "The Philosopher's Dinner:" << EPOS::S::endl;
++
++    for(int i = 0; i < 5; i++)
++        chopstick[i] = new Semaphore;
++
++    phil[0] = new EPOS::S::Thread(&philosopher, 0,  5, 32);
++    phil[1] = new EPOS::S::Thread(&philosopher, 1, 10, 44);
++    phil[2] = new EPOS::S::Thread(&philosopher, 2, 16, 39);
++    phil[3] = new EPOS::S::Thread(&philosopher, 3, 16, 24);
++    phil[4] = new EPOS::S::Thread(&philosopher, 4, 10, 20);
++
++    cout << "Philosophers are alive and hungry!" << EPOS::S::endl;
++
++    display.position(7, 44);
++    cout << '/';
++    display.position(13, 44);
++    cout << '\\';
++    display.position(16, 35);
++    cout << '|';
++    display.position(13, 27);
++    cout << '/';
++    display.position(7, 27);
++    cout << '\\';
++    display.position(19, 0);
++
++    cout << "The dinner is served ..." << EPOS::S::endl;
++    table.unlock();
++
++    for(int i = 0; i < 5; i++) {
++        int ret = phil[i]->join();
++        table.lock();
++        display.position(20 + i, 0);
++        cout << "Philosopher " << i << " ate " << ret << " times " << EPOS::S::endl;
++        table.unlock();
++    }
++
++    for(int i = 0; i < 5; i++)
++        delete chopstick[i];
++    for(int i = 0; i < 5; i++)
++        delete phil[i];
++
++    cout << "The end!" << EPOS::S::endl;
++
++    return 0;
++}
+Index: app/philosophers_dinner_traits.h
+===================================================================
+--- app/philosophers_dinner_traits.h	(revision 0)
++++ app/philosophers_dinner_traits.h	(working copy)
+@@ -0,0 +1,161 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Global Configuration
++template<typename T>
++struct Traits
++{
++    static const bool enabled = true;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = false;
++};
++
++template<> struct Traits<Build>
++{
++    enum {LIBRARY, BUILTIN};
++    static const unsigned int MODE = BUILTIN;
++
++    enum {IA32};
++    static const unsigned int ARCHITECTURE = IA32;
++
++    enum {PC};
++    static const unsigned int MACHINE = PC;
++
++    enum {Legacy};
++    static const unsigned int MODEL = Legacy;
++
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // > 1 => NETWORKING
++};
++
++
++// Utilities
++template<> struct Traits<Debug>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = false;
++};
++
++template<> struct Traits<Lists>: public Traits<void>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<void>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<void>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<void>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<void>
++{
++};
++
++template<> struct Traits<Init>: public Traits<void>
++{
++};
++
++
++// Mediators
++template<> struct Traits<Serial_Display>: public Traits<void>
++{
++    static const bool enabled = true;
++    static const int COLUMNS = 80;
++    static const int LINES = 24;
++    static const int TAB_SIZE = 8;
++};
++
++__END_SYS
++
++#include __ARCH_TRAITS_H
++#include __MACH_CONFIG_H
++#include __MACH_TRAITS_H
++
++__BEGIN_SYS
++
++
++// Abstractions
++template<> struct Traits<Application>: public Traits<void>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<void>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = (mode != Traits<Build>::LIBRARY) || Traits<Scratchpad>::enabled;
++
++    enum {FOREVER = 0, SECOND = 1, MINUTE = 60, HOUR = 3600, DAY = 86400, WEEK = 604800, MONTH = 2592000, YEAR = 31536000};
++    static const unsigned long LIFE_SPAN = 1 * HOUR; // in seconds
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<void>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<void>
++{
++    static const bool smp = Traits<System>::multicore;
++
++    typedef Scheduling_Criteria::RR Criterion;
++    static const unsigned int QUANTUM = 10000; // us
++
++    static const bool trace_idle = hysterically_debugged;
++};
++
++template<> struct Traits<Scheduler<Thread> >: public Traits<void>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++
++template<> struct Traits<Address_Space>: public Traits<void>
++{
++    static const bool enabled = Traits<System>::multiheap;
++};
++
++template<> struct Traits<Segment>: public Traits<void>
++{
++    static const bool enabled = Traits<System>::multiheap;
++};
++
++template<> struct Traits<Alarm>: public Traits<void>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<void>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++__END_SYS
++
++#endif
+
+Property changes on: app/philosophers_dinner_traits.h
+___________________________________________________________________
+Added: svn:executable
+## -0,0 +1 ##
++*
+\ No newline at end of property
+Index: app/task_test
+===================================================================
+Cannot display: file marked as a binary type.
+svn:mime-type = application/octet-stream
+Index: app/task_test
+===================================================================
+--- app/task_test	(revision 0)
++++ app/task_test	(working copy)
+
+Property changes on: app/task_test
+___________________________________________________________________
+Added: svn:executable
+## -0,0 +1 ##
++*
+\ No newline at end of property
+Added: svn:mime-type
+## -0,0 +1 ##
++application/octet-stream
+\ No newline at end of property
+Index: app/task_test.cc
+===================================================================
+--- app/task_test.cc	(revision 0)
++++ app/task_test.cc	(working copy)
+@@ -0,0 +1,127 @@
++// EPOS Task Test Program
++
++#include <utility/ostream.h>
++#include <stub/alarm.h>
++#include <thread.h>
++#include <stub/task.h>
++
++using namespace EPOS::APP;
++
++const int iterations = 10;
++
++int func_a(void);
++int func_b(void);
++
++EPOS::S::Thread * a;
++EPOS::S::Thread * b;
++EPOS::S::Thread * m;
++
++EPOS::S::OStream cout;
++
++int main()
++{
++    cout << "Task test" << EPOS::S::endl;
++
++    m = EPOS::S::Thread::self();
++
++    cout << "I'll try to clone myself:" << EPOS::S::endl;
++
++    const Task * task0 = Task::self();
++    Address_Space * as0 = task0->address_space();
++    cout << "My address space's page directory is located at " << as0->pd() << EPOS::S::endl;
++
++    const Segment * cs0 = task0->code_segment();
++    CPU::Log_Addr code0 = task0->code();
++    cout << "My code segment is located at "
++         << static_cast<void *>(code0)
++         << " and it is " << cs0->size() << " bytes long" << EPOS::S::endl;
++
++    const Segment * ds0 = task0->data_segment();
++    CPU::Log_Addr data0 = task0->data();
++    cout << "My data segment is located at "
++         << static_cast<void *>(data0)
++         << " and it is " << ds0->size() << " bytes long" << EPOS::S::endl;
++
++    cout << "Creating and attaching segments:" << EPOS::S::endl;
++    Segment cs1(cs0->size());
++    CPU::Log_Addr code1 = as0->attach(cs1);
++    cout << "  code => " << code1 << " done!" << EPOS::S::endl;
++    Segment ds1(ds0->size());
++    CPU::Log_Addr data1 = as0->attach(ds1);
++    cout << "  data => " << data1 << " done!" << EPOS::S::endl;
++
++    cout << "Copying segments:";
++    memcpy(code1, code0, cs1.size());
++    cout << " code => done!" << EPOS::S::endl;
++    memcpy(data1, data0, ds1.size());
++    cout << " data => done!" << EPOS::S::endl;
++
++    cout << "Detaching segments:";
++    as0->detach(cs1);
++    as0->detach(ds1);
++    cout << " done!" << EPOS::S::endl;
++
++    cout << "Creating the clone task:";
++    Task * task1 = new Task(cs1, ds1);
++    cout << " done!" << EPOS::S::endl;
++
++    cout << "Creating a thread over the cloned task:";
++    a = new Thread(task1, &func_a);
++    cout << " done!" << EPOS::S::endl;
++
++    cout << "Creating a thread over the main task:";
++    b = new Thread(&func_b);
++    cout << " done!" << EPOS::S::endl;
++
++    cout << "I'll now suspend my self to see the other threads running:" << EPOS::S::endl;
++    m->suspend();
++
++    cout << "Both threads are now done and have suspended themselves. I'll now wait for 1 second and then wake them up so they can exit ..." << EPOS::S::endl;
++
++    Alarm::delay(1000000);
++
++    a->resume();
++    b->resume();
++
++    int status_a = a->join();
++    int status_b = b->join();
++
++    cout << "Thread A exited with status " << status_a << " and thread B exited with status " << status_b << "." << EPOS::S::endl;
++
++    delete a;
++    delete b;
++    delete task1;
++
++    cout << "I'm also done, bye!" << EPOS::S::endl;
++
++    return 0;
++}
++
++
++int func_a(void)
++{
++    for(int i = iterations; i > 0; i--) {
++        for(int i = 0; i < 79; i++)
++            cout << "a";
++        cout << EPOS::S::endl;
++        Thread::yield();
++    }
++
++    Thread::self()->suspend();
++    return 'A';
++}
++
++int func_b(void)
++{
++    for(int i = iterations; i > 0; i--) {
++        for(int i = 0; i < 79; i++)
++            cout << "b";
++        cout << EPOS::S::endl;
++        Thread::yield();
++    }
++
++    m->resume();
++
++    Thread::self()->suspend();
++    return 'B';
++}
+Index: app/task_test_traits.h
+===================================================================
+--- app/task_test_traits.h	(revision 0)
++++ app/task_test_traits.h	(working copy)
+@@ -0,0 +1,161 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Global Configuration
++template<typename T>
++struct Traits
++{
++    static const bool enabled = true;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = false;
++};
++
++template<> struct Traits<Build>
++{
++    enum {LIBRARY, BUILTIN};
++    static const unsigned int MODE = BUILTIN;
++
++    enum {IA32};
++    static const unsigned int ARCHITECTURE = IA32;
++
++    enum {PC};
++    static const unsigned int MACHINE = PC;
++
++    enum {Legacy};
++    static const unsigned int MODEL = Legacy;
++
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // > 1 => NETWORKING
++};
++
++
++// Utilities
++template<> struct Traits<Debug>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = false;
++};
++
++template<> struct Traits<Lists>: public Traits<void>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<void>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<void>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<void>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<void>
++{
++};
++
++template<> struct Traits<Init>: public Traits<void>
++{
++};
++
++
++// Mediators
++template<> struct Traits<Serial_Display>: public Traits<void>
++{
++    static const bool enabled = true;
++    static const int COLUMNS = 80;
++    static const int LINES = 24;
++    static const int TAB_SIZE = 8;
++};
++
++__END_SYS
++
++#include __ARCH_TRAITS_H
++#include __MACH_CONFIG_H
++#include __MACH_TRAITS_H
++
++__BEGIN_SYS
++
++
++// Abstractions
++template<> struct Traits<Application>: public Traits<void>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<void>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = (mode != Traits<Build>::LIBRARY) || Traits<Scratchpad>::enabled;
++
++    enum {FOREVER = 0, SECOND = 1, MINUTE = 60, HOUR = 3600, DAY = 86400, WEEK = 604800, MONTH = 2592000, YEAR = 31536000};
++    static const unsigned long LIFE_SPAN = 1 * HOUR; // in seconds
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<void>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<void>
++{
++    static const bool smp = Traits<System>::multicore;
++
++    typedef Scheduling_Criteria::RR Criterion;
++    static const unsigned int QUANTUM = 10000; // us
++
++    static const bool trace_idle = hysterically_debugged;
++};
++
++template<> struct Traits<Scheduler<Thread> >: public Traits<void>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++
++template<> struct Traits<Address_Space>: public Traits<void>
++{
++    static const bool enabled = Traits<System>::multiheap;
++};
++
++template<> struct Traits<Segment>: public Traits<void>
++{
++    static const bool enabled = Traits<System>::multiheap;
++};
++
++template<> struct Traits<Alarm>: public Traits<void>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<void>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++__END_SYS
++
++#endif
+
+Property changes on: app/task_test_traits.h
+___________________________________________________________________
+Added: svn:executable
+## -0,0 +1 ##
++*
+\ No newline at end of property
+Index: app/test
+===================================================================
+Cannot display: file marked as a binary type.
+svn:mime-type = application/octet-stream
+Index: app/test
+===================================================================
+--- app/test	(revision 0)
++++ app/test	(working copy)
+
+Property changes on: app/test
+___________________________________________________________________
+Added: svn:executable
+## -0,0 +1 ##
++*
+\ No newline at end of property
+Added: svn:mime-type
+## -0,0 +1 ##
++application/octet-stream
+\ No newline at end of property
+Index: app/test.cc
+===================================================================
+--- app/test.cc	(revision 0)
++++ app/test.cc	(working copy)
+@@ -0,0 +1,93 @@
++#include <stub/semaphore.h>
++//#include <stub/alarm.h>
++//#include <stub/condition.h>
++//#include <stub/address_space.h>
++//#include <stub/segment.h>
++//#include <stub/mutex.h>
++//#include <stub/task.h>
++//#include <stub/ostream.h>
++//#include <stub/thread.h>
++
++using namespace EPOS::APP;
++
++int fn(int,int,int,int);
++void fun_void(void);
++
++int main()
++{
++    EPOS::S::OStream cout;
++
++
++    //Address_Space address;
++   // cout << "Addres Space=" << &address;
++
++    //Segment segment1 (16*1024);
++    //cout << ">>>>>>>>>>>>>>>>>>>>>Segment 1 = " << (void*) &segment1;
++//    cout << "Stub Test!" << endl;
++
++    //Log_Addr log_addr = address.attach(segment1);
++    //address.detach(segment1);
++
++    //Segment segment2 (log_addr, 16*1024);
++    //cout << "Segment2=" << &segment2;
++
++    //address.attach(segment2, log_addr);
++
++   // cout << "Fuuuuusão: " << (char)(fn (65, 1, 1, 1)) << endl;
++
++    //Thread t(&fn, 60,2,3,1);
++
++   // cout << ">>> Retorno do JOIN: [[" << (char) t.join() << "]]" << endl;
++
++//    cout << "KReat0Rs";
++
++
++//    Function_Handler fh(&fun_void);
++//    cout << "Function Handler=" << &fh;
++
++//    Alarm alarm(1000000,&fh,1);
++//    cout << "Alarm=" << &alarm;
++
++//    Condition condition;
++//    cout << "Condition=" << &condition;
++
++//    Condition_Handler ch(&condition);
++//    cout << "Condition Handler=" << &ch;
++
++//    Mutex mutex;
++//    cout << "Mutex=" << &mutex;
++
++//    Mutex_Handler mh(&mutex);
++//    cout << "Mutex Handler=" << &mh;
++
++
++    Semaphore semaphore;
++    cout << "Semaphore=" << &semaphore;
++
++//    Semaphore_Handler sh(&semaphore);
++//    cout << "Semaphore Handler=" << &sh;
++
++//    //Task task(segment1, segment2);
++
++//    Task *task = Task::self();
++//    cout << "Task=" << task;
++
++//    Alarm::delay(2000000);
++
++    cout << "BYE";
++    return 0;
++}
++
++int fn(int a, int b, int c, int d){
++    EPOS::S::OStream cout;
++    int e = a + b + c + d;
++    cout << "Fn = {" << ((char) e) << "}" << "\n";
++    return e;
++}
++
++
++//void fun_void(){
++//    OStream cout;
++//    Endl endl;
++//    cout << "Oi sou uma função que não retorna nada Emoticon smile " << endl;
++//}
+\ No newline at end of file
+Index: app/test_traits.h
+===================================================================
+--- app/test_traits.h	(revision 0)
++++ app/test_traits.h	(working copy)
+@@ -0,0 +1,161 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Global Configuration
++template<typename T>
++struct Traits
++{
++    static const bool enabled = true;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = false;
++};
++
++template<> struct Traits<Build>
++{
++    enum {LIBRARY, BUILTIN};
++    static const unsigned int MODE = BUILTIN;
++
++    enum {IA32};
++    static const unsigned int ARCHITECTURE = IA32;
++
++    enum {PC};
++    static const unsigned int MACHINE = PC;
++
++    enum {Legacy};
++    static const unsigned int MODEL = Legacy;
++
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // > 1 => NETWORKING
++};
++
++
++// Utilities
++template<> struct Traits<Debug>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = false;
++};
++
++template<> struct Traits<Lists>: public Traits<void>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<void>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<void>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<void>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<void>
++{
++};
++
++template<> struct Traits<Init>: public Traits<void>
++{
++};
++
++
++// Mediators
++template<> struct Traits<Serial_Display>: public Traits<void>
++{
++    static const bool enabled = true;
++    static const int COLUMNS = 80;
++    static const int LINES = 24;
++    static const int TAB_SIZE = 8;
++};
++
++__END_SYS
++
++#include __ARCH_TRAITS_H
++#include __MACH_CONFIG_H
++#include __MACH_TRAITS_H
++
++__BEGIN_SYS
++
++
++// Abstractions
++template<> struct Traits<Application>: public Traits<void>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<void>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = (mode != Traits<Build>::LIBRARY) || Traits<Scratchpad>::enabled;
++
++    enum {FOREVER = 0, SECOND = 1, MINUTE = 60, HOUR = 3600, DAY = 86400, WEEK = 604800, MONTH = 2592000, YEAR = 31536000};
++    static const unsigned long LIFE_SPAN = 1 * HOUR; // in seconds
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<void>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<void>
++{
++    static const bool smp = Traits<System>::multicore;
++
++    typedef Scheduling_Criteria::RR Criterion;
++    static const unsigned int QUANTUM = 10000; // us
++
++    static const bool trace_idle = hysterically_debugged;
++};
++
++template<> struct Traits<Scheduler<Thread> >: public Traits<void>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++
++template<> struct Traits<Address_Space>: public Traits<void>
++{
++    static const bool enabled = Traits<System>::multiheap;
++};
++
++template<> struct Traits<Segment>: public Traits<void>
++{
++    static const bool enabled = Traits<System>::multiheap;
++};
++
++template<> struct Traits<Alarm>: public Traits<void>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<void>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++__END_SYS
++
++#endif
+
+Property changes on: app/test_traits.h
+___________________________________________________________________
+Added: svn:executable
+## -0,0 +1 ##
++*
+\ No newline at end of property
+Index: bin/eposcc
+===================================================================
+--- bin/eposcc	(revision 0)
++++ bin/eposcc	(working copy)
+@@ -0,0 +1,400 @@
++#!/bin/sh
++#=========================================================================
++# Script to compile and link EPOS applications
++#=========================================================================
++
++#=========================================================================
++# PATHS
++#=========================================================================
++EPOS=/home/maria.eloisa/epos
++TMP=/tmp
++INC=$EPOS/include
++SRC=$EPOS/src
++APP=$EPOS/app
++BIN=$EPOS/bin
++LIB=$EPOS/lib
++IMG=$EPOS/img
++ETC=$EPOS/etc
++DOC=$EPOS/doc
++
++#=========================================================================
++# CONFIGURATION
++#=========================================================================
++. $ETC/eposcc.conf
++
++#=========================================================================
++# CUSTOMIZABLE DEFINITIONS
++#=========================================================================
++ANALYZER=eposanl
++ANL_FLGS="-u"
++ANL_COMP_FLGS="-DANALYZE"
++
++CONFIGURATOR=eposcfg
++
++COMP_FLGS="-include $INC/utility/malloc.h"
++COMP_HDRS="$INC"
++if [ "$MODE" = "kernel" ] ; then
++COMP_FLGS="$COMP_FLGS -include $INC/framework/main.h"
++fi
++
++C_COMPILER="$TOOLS_PREFIX""gcc"
++C_COMP_FLGS="$MACH_CC_FLAGS"
++C_COMP_HDRS=
++C_LINK_FLGS="$MACH_LD_FLAGS"
++C_LINK_OBJS=
++C_LINK_LIBS=
++
++CPP_COMPILER="$TOOLS_PREFIX""g++"
++CPP_COMP_FLGS="--no-exceptions --no-rtti --no-use-cxa-atexit -std=c++0x"
++CPP_COMP_HDRS=
++CPP_LINK_FLGS=
++CPP_LINK_OBJS=
++CPP_LINK_LIBS=
++
++F77_COMPILER="$TOOLS_PREFIX""g77"
++F77_COMP_FLGS=
++F77_COMP_HDRS=
++F77_LINK_FLGS=
++F77_LINK_OBJS=
++F77_LINK_LIBS="f2c"
++
++LINKER="$TOOLS_PREFIX""ld"
++
++LINKER_LIBRARY=$LINKER
++LINK_FLGS_LIBRARY="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --nmagic --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
++LINK_OBJI_LIBRARY="$LIB/$ARCH""_crt0.o $LIB/$ARCH""_crtbegin.o $LIB/$MACH""_init_first.o $LIB/$MACH""_init_application.o $LIB/$MACH""_application.o"
++LINK_OBJN_LIBRARY="$LIB/$MACH""_init_system.o $LIB/$MACH""_system.o $LIB/$ARCH""_crtend.o"
++LINK_LIBS_LIBRARY="util_$ARCH init_$ARCH sys_$ARCH mach_$ARCH arch_$ARCH util_$ARCH gcc"
++
++LINKER_BUILTIN=$LINKER
++LINK_FLGS_BUILTIN="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --nmagic --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
++LINK_OBJI_BUILTIN="$LIB/$ARCH""_crt0.o $LIB/$ARCH""_crtbegin.o $LIB/$MACH""_init_application.o  $LIB/$MACH""_application.o"
++LINK_OBJN_BUILTIN="$LIB/$ARCH""_crtend.o -R$SRC/system/$MACH""_system"
++LINK_LIBS_BUILTIN="util_$ARCH gcc"
++
++LINKER_KERNEL=$LINKER
++LINK_FLGS_KERNEL="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --nmagic --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
++LINK_OBJI_KERNEL="$LIB/$ARCH""_crt0.o $LIB/$ARCH""_crtbegin.o $LIB/$MACH""_init_application.o  $LIB/$MACH""_application.o"
++LINK_OBJN_KERNEL="$LIB/$ARCH""_crtend.o"
++LINK_LIBS_KERNEL="util_$ARCH arch_$ARCH gcc"
++
++#=========================================================================
++# VARIABLES
++#=========================================================================
++do_exec=eval
++do_echo=:
++need_link=1
++need_compile=0
++need_trace=0
++need_analyze=0
++only_analyze=0
++os_is_library=0
++os_is_builtin=0
++os_is_kernel=0
++os_is_linux=0
++language=C
++getting_output_file=0
++has_dash_c=0
++my_name=`basename $0`
++status=0
++
++#=========================================================================
++# ARGUMENT PARSING
++#=========================================================================
++for arg in "$@" ; do
++    if [ $getting_output_file = 1 ] ; then
++	getting_output_file=0
++	output_file="$arg"
++	continue
++    fi
++    case "$arg" in 
++    -c)
++	all_args="$all_args $arg"
++	compile_flgs="$compile_flgs $arg"
++	need_link=0
++	need_compile=1
++	has_dash_c=1
++	;;
++    -E)
++	all_args="$all_args $arg"
++	compile_flgs="$compile_flgs $arg"
++	need_link=0
++	has_dash_c=1
++	need_compile=1
++	;;
++    -S)
++	all_args="$all_args $arg"
++	compile_flgs="$compile_flgs $arg"
++	need_link=0
++	has_dash_c=1
++	need_compile=1
++	;;
++    -o)
++	all_args="$all_args $arg"
++	getting_output_file=1
++	;;
++    -l*)
++	libs="$libs $arg"
++	link_args="$link_args $arg"
++	all_args="$all_args $arg"
++	;;
++    --analyze)
++	need_analyze=1
++	only_analyze=1
++	need_link=0
++	need_compile=0
++	;;
++    --linux)
++	if [ $os_is_kernel = 1 -o $os_is_library = 1 -o $os_is_builtin = 1 ] ; then
++           echo "--builtin, --kernel, --library and --linux cannot be used together!"
++           exit -1
++	else
++	   os_is_linux=1
++	fi
++	;;
++    --builtin)
++	if [ $os_is_kernel = 1 -o $os_is_library = 1 -o $os_is_linux = 1 ] ; then
++	    echo "--builtin, --kernel, --library and --linux cannot be used together!"
++	    exit -1
++	else
++   	    os_is_builtin=1
++	fi
++	;;
++    --library)	
++	if [ $os_is_kernel = 1 -o $os_is_builtin = 1 -o $os_is_linux = 1 ] ; then
++	    echo "--builtin, --kernel, --library and --linux cannot be used together!"
++	    exit -1
++	else
++   	    os_is_library=1
++	fi
++	;;
++    --kernel)
++	if [ $os_is_library = 1 -o $os_is_builtin = 1 -o $os_is_linux = 1 ] ; then
++	    echo "--builtin, --kernel, --library and --linux cannot be used together!"
++	    exit -1
++	else
++	    os_is_kernel=1
++	fi
++	;;
++    --trace)
++	need_trace=1
++	;;
++    --echo)
++	do_echo=echo
++	;;
++    --show)
++	do_echo=echo
++	do_exec=:
++	;;
++    --help)
++	echo "This is a script to compile and/or link EPOS programs"
++	echo "written in C, C++ or Fortran."
++	echo
++	echo "In addition to your compiler options, the following is supported"
++	echo "  --analyze analyze application requirements"
++	echo "  --library EPOS is a library to be linked with the application"
++	echo "  --builtin EPOS is built-in the application"
++	echo "  --kernel  EPOS is a microkernel"
++	echo "  --linux   EPOS is guest at Linux"
++	echo "  --trace   instruct EPOS to generate traces"
++	echo "  --show    show commands without issuing them"
++	echo "  --help    print this help"
++	echo "  --echo    show what this script is doing"
++	echo
++	echo "This script should be used just like your usual compiler, e.g.:"
++	echo "   $my_name -c foo.cc"
++	echo "   $my_name -o foo foo.o"
++	echo "   $my_name -c -O -Llibrary_path -Iheader_path -o foo foo.c"
++	exit 1
++	;;
++    *\"*) 
++	all_args="$all_args `echo $arg | sed 's/\"/\\\"/g'`"
++	compile_flgs="$compile_flgs `echo $arg | sed 's/\"/\\\"/g'`"
++	link_flgs="$link_flgs `echo $arg | sed 's/\"/\\\"/g'`"
++	;;
++    *)
++	all_args="$all_args $arg"
++	if [ -s "$arg" ] ; then
++	    ext=`expr "$arg" : '.*\(\..*\)'`
++	    if [ "$ext" = ".c" ] ; then
++		language="C"
++	        need_compile=1
++	        input_file="$arg"
++		key_file="`basename $arg $ext`.key"
++	        link_objs="$link_objs `basename $arg $ext`.o"
++	    elif [ "$ext" = ".f" ] ; then
++		language="F77"
++	        need_compile=1
++	        input_file="$arg"
++		key_file="`basename $arg $ext`.key"
++	        link_objs="$link_objs `basename $arg $ext`.o"
++	    elif [ "$ext" = ".C" -o "$ext" = ".cpp" -o "$ext" = ".cc" ] ; then
++		language="CPP"
++	        need_compile=1
++	        input_file="$arg"
++		key_file="`basename $arg $ext`.key"
++	        link_objs="$link_objs `basename $arg $ext`.o"
++	    elif [ "$ext" = ".o" ] ; then
++		if [ $need_compile = 1 ] ; then
++	            compile_args="$compile_args $arg"
++                else
++	            need_link=1
++	            link_objs="$link_objs $arg"
++                fi
++	    else
++	        compile_args="$compile_args $arg"
++	        link_args="$link_args $arg"
++	    fi
++	else
++            compile_flgs="$compile_flgs $arg"
++	    link_flgs="$link_flgs $arg"
++	fi
++	;;
++    esac
++done
++
++#=========================================================================
++# COMMAND ISSUING
++#=========================================================================
++if [ "$language" = "F77" ] ; then
++    compiler=$F77_COMPILER
++    compile_flgs="$compile_flgs $F77_COMP_FLGS"
++    for hdr in $F77_COMP_HDRS ; do
++	compile_flgs="$compile_flgs -I$hdr"
++    done
++    link_flgs="$link_flgs $F77_LINK_FLGS"
++    link_objs="$F77_LINK_OBJS $link_objs"
++    for lib in $F77_LINK_LIBS ; do
++	link_libs="$link_libs -l$lib"
++    done
++elif [ "$language" = "CPP" ] ; then
++    compiler=$CPP_COMPILER
++    compile_flgs="$compile_flgs $CPP_COMP_FLGS"
++    for hdr in $CPP_COMP_HDRS ; do
++	compile_flgs="$compile_flgs -I$hdr"
++    done
++    link_flgs="$link_flgs $CPP_LINK_FLGS"
++    link_objs="$CPP_LINK_OBJS $link_objs"
++    for lib in $CPP_LINK_LIBS ; do
++	link_libs="$link_libs -l$lib"
++    done
++else
++    compiler=$C_COMPILER
++    compile_flgs="$compile_flgs $C_COMP_FLGS"
++    for hdr in $C_COMP_HDRS ; do
++	compile_flgs="$compile_flgs -I$hdr"
++    done
++    link_flgs="$link_flgs $C_LINK_FLGS"
++    link_objs="$C_LINK_OBJS $link_objs"
++    for lib in $C_LINK_LIBS ; do
++	link_libs="$link_libs -l$lib"
++    done
++fi
++
++compile_flgs="$compile_flgs $COMP_FLGS"
++for hdr in $COMP_HDRS ; do
++    compile_flgs="$compile_flgs -I$hdr"
++done
++
++if [ $os_is_kernel = 1 ] ; then
++        LINKER=$LINKER_KERNEL
++	LINK_FLGS=$LINK_FLGS_KERNEL
++	LINK_OBJI=$LINK_OBJI_KERNEL
++	LINK_OBJN=$LINK_OBJN_KERNEL
++	LINK_LIBS=$LINK_LIBS_KERNEL
++    elif [ $os_is_library = 1 ] ; then
++	LINKER=$LINKER_LIBRARY
++	LINK_FLGS=$LINK_FLGS_LIBRARY
++	LINK_OBJI=$LINK_OBJI_LIBRARY
++	LINK_OBJN=$LINK_OBJN_LIBRARY
++	LINK_LIBS=$LINK_LIBS_LIBRARY
++    elif [ $os_is_builtin = 1 ] ; then
++	LINKER=$LINKER_BUILTIN
++	LINK_FLGS=$LINK_FLGS_BUILTIN
++	LINK_OBJI=$LINK_OBJI_BUILTIN
++	LINK_OBJN=$LINK_OBJN_BUILTIN
++	LINK_LIBS=$LINK_LIBS_BUILTIN
++fi
++	
++linker=$LINKER
++link_flgs="$link_flgs $LINK_FLGS"
++link_objs="$LINK_OBJI $link_objs $LINK_OBJN"
++for lib in $LINK_LIBS ; do
++  link_libs="$link_libs -l$lib"
++done
++
++if [ $need_compile = 1 -a ! -f "$key_file" ] ; then
++    need_analyze=1
++fi
++
++# disabled for EPOS
++if [ $need_analyze = 5 ] ; then
++    analyze_flgs=$compile_flgs
++
++    if [ $has_dash_c = 0 ] ; then
++	analyze_flgs="-c $analyze_flgs"
++    fi
++    tmp_file="$TMP/epos`date +%Y%m%d%H%M%S`"
++    analyze_flgs="$analyze_flgs $ANL_COMP_FLGS"
++    analyze_flgs="$analyze_flgs -o $tmp_file.o"
++    $do_echo $compiler $analyze_flgs $analyze_args $input_file
++    $do_exec $compiler $analyze_flgs $analyze_args $input_file
++    status=$?
++    if [ $status != 0 ] ; then
++	$do_echo rm -f "$tmp_file.*"
++	$do_exec rm -f "$tmp_file.*"
++	exit $status
++    fi
++
++    $do_echo $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
++    $do_exec $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
++    status=$?
++    if [ $status != 0 ] ; then
++	$do_echo rm -f "$tmp_file.*"
++	$do_exec rm -f "$tmp_file.*"
++	exit $status
++    fi
++
++    if [ $only_analyze = 1 -a -n "$output_file" ] ; then
++	configurator_output_file=$output_file
++    else
++	configurator_output_file=$key_file
++    fi
++    $do_echo $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
++    $do_exec $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
++
++    status=$?
++    $do_echo rm -f "$tmp_file.*"
++    $do_exec rm -f "$tmp_file.*"
++
++    if [ $only_analyze = 1 ] ; then
++	exit $status
++    fi
++fi
++
++if [ $need_compile = 1 ] ; then
++    if [ $has_dash_c = 0 ] ; then
++	compile_flgs="-c $compile_flgs"
++    fi
++    if [ $has_dash_c = 1 -a -n "$output_file" ] ; then
++	compile_flgs="$compile_flgs -o $output_file"
++    fi
++    compile_flgs="$compile_flgs -DCONFIG_KEYS=\\\"$PWD/$key_file\\\""
++    $do_echo $compiler $compile_flgs $compile_args $input_file
++    $do_exec $compiler $compile_flgs $compile_args $input_file
++    status=$?
++    if [ $status != 0 ] ; then 
++	exit $status
++    fi
++fi
++
++if [ $need_link = 1 ] ; then
++    if [ -n "$output_file" ] ; then
++	link_flgs="$link_flgs -o $output_file"
++    fi
++    $do_echo "$linker $link_flgs $link_objs $link_args $link_libs"
++    $do_exec $linker $link_flgs $link_objs $link_args $link_libs
++    status=$?
++fi
++
++exit $status
+
+Property changes on: bin/eposcc
+___________________________________________________________________
+Added: svn:executable
+## -0,0 +1 ##
++*
+\ No newline at end of property
+Index: bin/eposmkbi
+===================================================================
+Cannot display: file marked as a binary type.
+svn:mime-type = application/octet-stream
+Index: bin/eposmkbi
+===================================================================
+--- bin/eposmkbi	(revision 0)
++++ bin/eposmkbi	(working copy)
+
+Property changes on: bin/eposmkbi
+___________________________________________________________________
+Added: svn:executable
+## -0,0 +1 ##
++*
+\ No newline at end of property
+Added: svn:mime-type
+## -0,0 +1 ##
++application/octet-stream
+\ No newline at end of property
Index: etc/eposcc.conf
===================================================================
--- etc/eposcc.conf	(revision 0)
+++ etc/eposcc.conf	(working copy)
@@ -0,0 +1,11 @@
+MODE=builtin
+ARCH=ia32
+MACH=pc
+MMOD=legacy
+TOOLS_PREFIX=/usr/local/ia32/gcc-4.4.4/bin/ia32-
+APP_CODE=0x00000000
+APP_DATA=0x00400000
+MACH_CC_FLAGS='-Wa,--32'
+MACH_LD_FLAGS=''
+MACH_CODE_NAME='.init'
+MACH_DATA_NAME='.ctors'
Index: etc/eposmkbi.conf
===================================================================
--- etc/eposmkbi.conf	(revision 0)
+++ etc/eposmkbi.conf	(working copy)
@@ -0,0 +1,11 @@
+MODE=builtin
+ARCH=ia32
+MACH=pc
+MMOD=legacy
+CLOCK=2000000000
+WORD_SIZE=32
+ENDIANESS=little
+MEM_BASE=0x00000000
+MEM_TOP=0x10000000
+BOOT_LENGTH_MIN=128
+BOOT_LENGTH_MAX=512
Index: img/pc_boot
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: img/pc_boot
===================================================================
--- img/pc_boot	(revision 0)
+++ img/pc_boot	(working copy)

Property changes on: img/pc_boot
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: img/pc_init
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: img/pc_init
===================================================================
--- img/pc_init	(revision 0)
+++ img/pc_init	(working copy)

Property changes on: img/pc_init
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: img/pc_setup
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: img/pc_setup
===================================================================
--- img/pc_setup	(revision 0)
+++ img/pc_setup	(working copy)

Property changes on: img/pc_setup
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: img/pc_system
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: img/pc_system
===================================================================
--- img/pc_system	(revision 0)
+++ img/pc_system	(working copy)

Property changes on: img/pc_system
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: img/task_test
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: img/task_test
===================================================================
--- img/task_test	(revision 0)
+++ img/task_test	(working copy)

Property changes on: img/task_test
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: img/task_test.img
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: img/task_test.img
===================================================================
--- img/task_test.img	(revision 0)
+++ img/task_test.img	(working copy)

Property changes on: img/task_test.img
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: img/task_test.out
===================================================================
--- img/task_test.out	(revision 0)
+++ img/task_test.out	(working copy)
@@ -0,0 +1,51 @@
+Setting up this machine as follows: 
+  Processor:    IA32 at 2204 MHz (BUS clock = 125 MHz)
+  Memory:       262144 Kbytes [0x00000000:0x10000000]
+  User memory:  261744 Kbytes [0x00000000:0x0ff9c000]
+  PCI aperture: 45064 Kbytes [0xfc000000:0xfec02000]
+  Node Id:      will get from the network!
+  Setup:        20864 bytes
+  Init:         6512 bytes
+  OS code:      52064 bytes	data: 608 bytes	stack: 16384 bytes
+  APP code:     4832 bytes	data: 16797696 bytes
+Task test
+I'll try to clone myself:
+My address space's page directory is located at 0x0fffc000
+My code segment is located at 0x00000000 and it is 8192 bytes long
+My data segment is located at 0x00400000 and it is 16797696 bytes long
+Creating and attaching segments:
+  code => 0x10000000 done!
+  data => 0x10400000 done!
+Copying segments: code => done!
+ data => done!
+Detaching segments: done!
+Creating the clone task: done!
+Creating a thread over the cloned task: done!
+Creating a thread over the main task: done!
+I'll now suspend my self to see the other threads running:
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
+aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
+Both threads are now done and have suspended themselves. I'll now wait for 1 sec
+ond and then wake them up so they can exit ...
+Thread A exited with status 65 and thread B exited with status 66.
+I'm also done, bye!
+The last thread has exited!
+Rebooting the machine ...
Index: img/test
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: img/test
===================================================================
--- img/test	(revision 0)
+++ img/test	(working copy)

Property changes on: img/test
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: img/test.img
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: img/test.img
===================================================================
--- img/test.img	(revision 0)
+++ img/test.img	(working copy)

Property changes on: img/test.img
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: img/test.out
===================================================================
--- img/test.out	(revision 0)
+++ img/test.out	(working copy)
@@ -0,0 +1,1816 @@
+Setting up this machine as follows: 
+  Processor:    IA32 at 2209 MHz (BUS clock = 125 MHz)
+  Memory:       262144 Kbytes [0x00000000:0x10000000]
+  User memory:  261744 Kbytes [0x00000000:0x0ff9c000]
+  PCI aperture: 45064 Kbytes [0xfc000000:0xfec02000]
+  Node Id:      will get from the network!
+  Setup:        20864 bytes
+  Init:         6512 bytes
+  OS code:      52064 bytes	data: 608 bytes	stack: 16384 bytes
+  APP code:     1040 bytes	data: 16797696 bytes
+Semaphore=0xff843efcBYEIC::exc_pf(i=14) => [address=0x9090909c,err={},ctx={cs=0,
+ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={S},ctx={cs=0xff843f80,ip=30,fl=0xff
+83bee0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
+IC::exc_pf(i=14) => [address=0x909090b0,err={},ctx={cs=0,ip=0,fl=0}]
+The running thread will now be terminated!
Index: include/app_types.h
===================================================================
--- include/app_types.h	(revision 0)
+++ include/app_types.h	(working copy)
@@ -0,0 +1,71 @@
+#ifndef __app_types_h
+#define __app_types_h
+
+#include <system/config.h>
+#include <tsc.h>
+#include <rtc.h>
+
+__BEGIN_API
+
+	typedef RTC::Microsecond Microsecond;
+	typedef TSC::Hertz Hertz;
+	
+namespace Class {
+	enum { ADDRESS_SPACE, 
+		   ALARM, 
+		   CONDITION, 
+		   DISPLAY,
+		   HANDLER,
+		   MUTEX, 
+		   SEGMENT,
+		   SEMAPHORE,
+		   TASK,
+		   THREAD };
+}
+
+namespace Method {
+
+	namespace Address_Space {
+		enum { CONSTRUCTOR_1, CONSTRUCTOR_2, DESTRUCTOR, ATTACH_1, ATTACH_2, DETACH, PHYSICAL };
+	}
+	
+	namespace Alarm {
+		enum { CONSTRUCTOR, DESTRUCTOR, FREQUENCY, DELAY };
+	}
+	
+	namespace Condition {
+		enum { CONSTRUCTOR, DESTRUCTOR, WAIT, SIGNAL, BROADCAST };
+	}
+	
+	namespace Display {
+		enum { CONSTRUCTOR, CLEAR, PUTC, PUTS, GEOMETRY, POSITION_1, POSITION_2 };
+	}
+	
+	namespace Handler {
+		enum { CONSTRUCTOR, DESTRUCTOR, OPERATOR };
+	}
+	
+	namespace Mutex {
+		enum { CONSTRUCTOR, DESTRUCTOR, LOCK, UNLOCK };
+	}
+	
+	namespace Segment {
+		enum { CONSTRUCTOR_1, CONSTRUCTOR_2, DESTRUCTOR, SIZE, PHY_ADDRESS, RESIZE };
+	}
+	
+	namespace Semaphore {
+		enum { CONSTRUCTOR, DESTRUCTOR, P, V };
+	}
+	
+	namespace Task {
+		enum { CONSTRUCTOR, DESTRUCTOR, ADDRESS_SPACE, CODE_SEGMENT, CODE, DATA_SEGMENT, DATA, SELF };
+	}
+
+	namespace Thread {
+		enum { CONSTRUCTOR_1, CONSTRUCTOR_2, CONSTRUCTOR_3, CONSTRUCTOR_4, DESTRUCTOR, STATE, PRIORITY_1, PRIORITY_2, TASK, JOIN, PASS, SUSPEND, RESUME, SELF, YIELD, EXIT };
+	}
+}
+	
+__END_API
+
+#endif
\ No newline at end of file
Index: include/stub/address_space.h
===================================================================
--- include/stub/address_space.h	(revision 0)
+++ include/stub/address_space.h	(working copy)
@@ -0,0 +1,79 @@
+#ifndef __address_space_h
+#define __address_space_h
+
+#include <app_types.h>
+#include <stub/message.h>
+#include <stub/skeleton.h>
+
+__BEGIN_APP
+
+class Address_Space {
+
+public:
+
+    Address_Space() {
+		message = new Message();
+    	message->class_id(Class::ADDRESS_SPACE);
+    	message->method_id(Method::Address_Space::CONSTRUCTOR_1);
+    	Skeleton::call(message);
+    	_obj_id = message->return_value();
+    };
+	
+	Address_Space(MMU::Page_Directory * pd) {
+		message = new Message();
+    	message->class_id(Class::ADDRESS_SPACE);
+    	message->method_id(Method::Address_Space::CONSTRUCTOR_2);
+		message->param1((void*) &pd);
+    	Skeleton::call(message);
+    	_obj_id = message->return_value();
+    };
+	
+    ~Address_Space(){
+    	message->class_id(Class::ADDRESS_SPACE);
+    	message->method_id(Method::Address_Space::DESTRUCTOR);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		delete message;
+    };
+
+    Log_Addr attach(const Segment & seg) {
+    	message->class_id(Class::ADDRESS_SPACE);
+    	message->method_id(Method::Address_Space::ATTACH_1);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Log_Addr address = reinterpret_cast<Log_Addr> message->return_value();
+		return address;
+    };
+
+	Log_Addr attach(const Segment & seg, Address_Space::Log_Addr addr) {
+    	message->class_id(Class::ADDRESS_SPACE);
+    	message->method_id(Method::Address_Space::ATTACH_2;
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Address_Space * address_space = reinterpret_cast<Address_Space *> message->return_value();
+		return address_space;
+    };
+	
+    void detach(const Segment & seg){
+    	message->class_id(Class::ADDRESS_SPACE);
+    	message->method_id(Method::Address_Space::DETACH);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+    };
+	
+	Phy_Addr physical(Address_Space::Log_Addr address) {
+    	message->class_id(Class::ADDRESS_SPACE);
+    	message->method_id(Method::Address_Space::PHYSICAL);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Address_Space * address_space = reinterpret_cast<Address_Space *> message->return_value();
+		return address_space;
+    };
+
+private:
+   void * _obj_id;
+   Message * message;
+};
+
+__END_APP
+#endif
\ No newline at end of file
Index: include/stub/alarm.h
===================================================================
--- include/stub/alarm.h	(revision 0)
+++ include/stub/alarm.h	(working copy)
@@ -0,0 +1,55 @@
+#ifndef __alarm_h
+#define __alarm_h
+
+#include <app_types.h>
+#include <stub/message.h>
+#include <stub/skeleton.h>
+
+__BEGIN_APP
+
+class Alarm {
+	
+public:
+
+    Alarm(const Microsecond &time, Handler * handler, int times = 1) {
+		message = new Message();
+    	message->class_id(Class::ALARM);
+    	message->method_id(Method::Alarm::CONSTRUCTOR);
+		message->param1((void*) &time);
+		message->param2((void*) &handler);
+		message->param3((void*) &times);
+    	Skeleton::call(message);
+    	_obj_id = message->return_value();
+    };
+	
+	~Alarm(){
+    	message->class_id(Class::ALARM);
+    	message->method_id(Method::Alarm::DESTRUCTOR);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		delete message;
+    };
+
+    static Hertz frequency() {
+		Message message = Message();
+    	message.class_id(Class::ALARM);
+    	message.method_id(Method::Alarm::FREQUENCY);
+    	Skeleton::call(&message);
+		Hertz frequency = reinterpret_cast<Hertz> (message.return_value());
+		return frequency;
+    };
+
+	static void delay(const Microsecond & time) {
+		Message message = Message();
+    	message.class_id(Class::ALARM);
+    	message.method_id(Method::Alarm::DELAY);
+    	Skeleton::call(&message);
+    };
+	
+private:
+	void * _obj_id;
+	Message * message;
+};
+
+__END_APP
+#endif
\ No newline at end of file
Index: include/stub/condition.h
===================================================================
--- include/stub/condition.h	(revision 0)
+++ include/stub/condition.h	(working copy)
@@ -0,0 +1,57 @@
+#ifndef __address_space_h
+#define __address_space_h
+
+#include <app_types.h>
+#include <stub/message.h>
+#include <stub/skeleton.h>
+
+__BEGIN_APP
+
+class Condition {
+
+public:
+
+    Condition() {
+		message = new Message();
+    	message->class_id(Class::CONDITION);
+    	message->method_id(Method::Condition::CONSTRUCTOR);
+    	Skeleton::call(message);
+    	_obj_id = message->return_value();
+    };
+	
+    ~Condition(){
+    	message->class_id(Class::CONDITION);
+    	message->method_id(Method::Condition::DESTRUCTOR);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		delete message;
+    };
+
+    void wait() {
+    	message->class_id(Class::CONDITION);
+    	message->method_id(Method::Condition::WAIT);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+    };
+
+    void signal(){
+    	message->class_id(Class::CONDITION);
+    	message->method_id(Method::Condition::SIGNAL);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+    };
+	
+	void broadcast(){
+    	message->class_id(Class::CONDITION);
+    	message->method_id(Method::Condition::BROADCAST);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+    };
+	
+private:
+   void * _obj_id;
+   Message * message;
+};
+
+__END_APP
+#endif
\ No newline at end of file
Index: include/stub/display.h
===================================================================
--- include/stub/display.h	(revision 0)
+++ include/stub/display.h	(working copy)
@@ -0,0 +1,74 @@
+#ifndef __display_h
+#define __display_h
+
+#include <app_types.h>
+#include <stub/message.h>
+#include <stub/skeleton.h>
+
+__BEGIN_APP
+
+class Display {
+
+public:
+	Display() {
+		message->class_id(Class::DISPLAY);
+    	message->method_id(Method::Display::CONSTRUCTOR);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+	}
+
+    static void clear() {
+    	message->class_id(Class::DISPLAY);
+    	message->method_id(Method::Display::CLEAR);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+    };
+
+	static void putc() {
+    	message->class_id(Class::DISPLAY);
+    	message->method_id(Method::Display::PUTC);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+    };
+	
+	static void puts(const char * s) {
+    	message->class_id(Class::DISPLAY);
+    	message->method_id(Method::Display::PUTS);
+    	message->object_id(_obj_id);
+		message->param1((void*) s);
+    	Skeleton::call(message);
+    };
+	
+	static void geometry(int * lines, int * columns) {
+    	message->class_id(Class::DISPLAY);
+    	message->method_id(Method::Display::GEOMETRY);
+    	message->object_id(_obj_id);
+		message->param1((void*) &lines);
+		message->param2((void*) &columns);
+    	Skeleton::call(message);
+    };
+	
+	static void position(int * line, int * column) {
+    	message->class_id(Class::DISPLAY);
+    	message->method_id(Method::Display::POSITION_1);
+    	message->object_id(_obj_id);
+		message->param1((void*) &line);
+		message->param2((void*) &column);
+    	Skeleton::call(message);
+    };
+	
+	static void position(int line, int column) {
+    	message->class_id(Class::DISPLAY);
+    	message->method_id(Method::Display::POSITION_2);
+    	message->object_id(_obj_id);
+		message->param1((void*) line);
+		message->param2((void*) column);
+    	Skeleton::call(message);
+    };
+private:
+	void * _obj_id;
+	Message * message;
+};
+
+__END_APP
+#endif
\ No newline at end of file
Index: include/stub/message.h
===================================================================
--- include/stub/message.h	(revision 0)
+++ include/stub/message.h	(working copy)
@@ -0,0 +1,68 @@
+#ifndef __message_h
+#define __message_h
+
+#include <system/config.h>
+
+__BEGIN_API
+
+class Message {
+
+public:
+	void class_id(int id);
+	int class_id();
+
+	void method_id(int id);
+	int method_id();
+
+	void object_id(void * id);
+	void * object_id();
+
+	void param1(void * ptr);
+	void * param1();
+
+	void param2(void * ptr);
+	void * param2();
+
+	void param3(void * ptr);
+	void * param3();
+
+	void param4(void * ptr);
+	void * param4();
+
+	void param5(void * ptr);
+	void * param5();
+
+	void param6(void * ptr);
+	void * param6();
+
+	void param7(void * ptr);
+	void * param7();
+
+	void variadic1(void ...);
+	void * variadic1();
+	
+	void variadic2(void ...);
+	void * variadic2();
+	
+	void return_value(void * ptr);
+	void * return_value();
+
+private:
+	int _class_id;
+	int _method_id;
+	void * _object_id;
+	void * _return;
+	void * _param1;
+	void * _param2;
+	void * _param3;
+	void * _param4;
+	void * _param5;
+	void * _param6;
+	void * _param7;
+	void * _variadic1[];
+	void * _variadic2[];
+	
+};
+
+__END_API
+#endif
Index: include/stub/mutex.h
===================================================================
--- include/stub/mutex.h	(revision 0)
+++ include/stub/mutex.h	(working copy)
@@ -0,0 +1,49 @@
+#ifndef __mutex_h
+#define __mutex_h
+
+#include <app_types.h>
+#include <stub/message.h>
+#include <stub/skeleton.h>
+
+__BEGIN_APP
+
+class Mutex {
+
+public:
+	Mutex() {
+		message = new Message();
+    	message->class_id(Class::MUTEX);
+    	message->method_id(Method::Mutex::CONSTRUCTOR);
+    	Skeleton::call(message);
+    	_obj_id = message->return_value();
+	}
+	
+	~Mutex() {
+		message->class_id(Class::MUTEX);
+    	message->method_id(Method::Mutex::DESTRUCTOR);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		delete message;
+	}
+	
+	void lock() {
+		message->class_id(Class::MUTEX);
+    	message->method_id(Method::Mutex::LOCK);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+	}
+	
+	void unlock() {
+		message->class_id(Class::MUTEX);
+    	message->method_id(Method::Mutex::UNLOCK);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+	}
+	
+private:
+	void * _obj_id;
+	Message * message;
+};
+
+__END_APP
+#endif
Index: include/stub/segment.h
===================================================================
Index: include/stub/semaphore.h
===================================================================
--- include/stub/semaphore.h	(revision 0)
+++ include/stub/semaphore.h	(working copy)
@@ -0,0 +1,50 @@
+#ifndef __semaphore_h
+#define __semaphore_h
+
+#include <app_types.h>
+#include <stub/message.h>
+#include <stub/skeleton.h>
+
+__BEGIN_APP
+
+class Semaphore {
+
+public:
+    Semaphore(int v = 1){
+		message = new Message();
+    	message->class_id(Class::SEMAPHORE);
+    	message->method_id(Method::Semaphore::CONSTRUCTOR);
+    	message->param1((void*) &v);
+    	Skeleton::call(message);
+    	_obj_id = message->return_value();
+    };
+	
+    ~Semaphore(){
+    	message->class_id(Class::SEMAPHORE);
+    	message->method_id(Method::Semaphore::DESTRUCTOR);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		delete message;
+    };
+
+    void p(){
+    	message->class_id(Class::SEMAPHORE);
+    	message->method_id(Method::Semaphore::P);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+    };
+
+    void v(){
+    	message->class_id(Class::SEMAPHORE);
+    	message->method_id(Method::Semaphore::V);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+    };
+
+private:
+	void * _obj_id;
+	Message * message;
+};
+
+__END_APP
+#endif
\ No newline at end of file
Index: include/stub/skeleton.h
===================================================================
--- include/stub/skeleton.h	(revision 0)
+++ include/stub/skeleton.h	(working copy)
@@ -0,0 +1,100 @@
+#ifndef __skeleton_h
+#define __skeleton_h
+
+#include <stub/message.h>
+
+__BEGIN_SYS
+
+class Skeleton {
+
+public:
+	static void call(Message * m);
+	
+private:
+	// Address Space
+	static void address_space_constructor_1(Message * m);
+	static void address_space_constructor_2(Message * m);
+	static void address_space_destructor(Message * m);
+	static void address_space_attach_1(Message * m);
+	static void address_space_attach_2(Message * m);
+	static void address_space_detach(Message * m);
+	static void address_space_physical(Message * m);
+
+	// Alarm
+	static void alarm_constructor(Message * m);
+	static void alarm_destructor(Message * m);
+	static void alarm_frequency(Message * m);
+	static void alarm_delay(Message * m);
+	
+	// Condition
+	static void condition_constructor(Message * m);
+	static void condition_destructor(Message * m);
+	static void condition_wait(Message * m);
+	static void condition_signal(Message * m);
+	static void condition_broadcast(Message * m);
+	
+	// Display
+	static void display_constructor(Message * m);
+	static void display_clear(Message * m);
+	static void display_putc(Message * m);
+	static void display_puts(Message * m);
+	static void display_geometry(Message * m);
+	static void display_position_1(Message * m);
+	static void display_position_2(Message * m);
+	
+	// Handler
+	static void handler_constructor(Message * m);
+	static void handler_destructor(Message * m);
+	static void handler_operator(Message * m);
+	
+	// Mutex
+	static void mutex_constructor(Message * m);
+	static void mutex_destructor(Message * m);
+	static void mutex_lock(Message * m);	
+	static void mutex_unlock(Message * m);
+	
+	// Segment
+	static void segment_constructor_1(Message * m);
+	static void segment_constructor_2(Message * m);
+	static void segment_destructor(Message * m);
+	static void segment_size(Message * m);
+	static void segment_phy_address(Message * m);
+	static void segment_resize(Message * m);
+		
+	// Semaphore
+	static void semaphore_constructor(Message * m);
+	static void semaphore_destructor(Message * m);
+	static void semaphore_p(Message * m);
+	static void semaphore_v(Message * m);
+	
+	// Task
+	static void task_constructor(Message * m);
+	static void task_destructor(Message * m);
+	static void task_address_space(Message * m);
+	static void task_code_segment(Message * m);
+	static void task_code(Message * m);
+	static void task_data_segment(Message * m);
+	static void task_data(Message * m);
+	static void task_self(Message * m);
+	
+	// Thread
+	static void thread_constructor_1(Message * m);
+	static void thread_constructor_2(Message * m);
+	static void thread_constructor_3(Message * m);
+	static void thread_constructor_4(Message * m);
+	static void thread_destructor(Message * m);
+	static void thread_state(Message * m);
+	static void thread_priority_1(Message * m);
+	static void thread_priority_2(Message * m);
+	static void thread_task(Message * m);
+	static void thread_join(Message * m);
+	static void thread_pass(Message * m);
+	static void thread_suspend(Message * m);
+	static void thread_resume(Message * m);
+	static void thread_self(Message * m);
+	static void thread_yield(Message * m);
+	static void thread_exit(Message * m);
+};
+
+__END_SYS
+#endif
\ No newline at end of file
Index: include/stub/task.h
===================================================================
--- include/stub/task.h	(revision 0)
+++ include/stub/task.h	(working copy)
@@ -0,0 +1,97 @@
+#ifndef __task_h
+#define __task_h
+
+#include <app_types.h>
+#include <stub/message.h>
+#include <stub/skeleton.h>
+
+__BEGIN_APP
+
+class Task {
+
+public:
+
+    Task(const Segment &cs, const Segment &ds) {
+		message = new Message();
+    	message->class_id(Class::TASK);
+    	message->method_id(Method::Task::CONSTRUCTOR);
+    	message->param1((void*) cs);
+    	message->param2((void*) ds);
+    	Skeleton::call(message);
+    	_obj_id = message->return_value();
+    };
+	
+    ~Task(){
+    	message->class_id(Class::TASK);
+    	message->method_id(Method::Task::DESTRUCTOR);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		delete message;
+    };
+
+    Address_Space * address_space() {
+    	message->class_id(Class::TASK);
+    	message->method_id(Method::Task::ADDRESS_SPACE);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Address_Space * address_space = reinterpret_cast<Address_Space *> message->return_value();
+		return address_space;
+    };
+
+    const Segment * code_segment(){
+    	message->class_id(Class::TASK);
+    	message->method_id(Method::Task::CODE_SEGMENT);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Segment * cs = reinterpret_cast<Segment *> message->return_value();
+		return cs;
+    };
+	
+	const Segment * data_segment(){
+    	message->class_id(Class::TASK);
+    	message->method_id(Method::Task::DATA_SEGMENT);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Segment * ds = reinterpret_cast<Segment *> message->return_value();
+		return ds;
+    };
+	
+	Log_Addr code(){
+    	message->class_id(Class::TASK);
+    	message->method_id(Method::Task::CODE);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Log_Addr code = reinterpret_cast<Log_Addr> message->return_value();
+		return code;
+    };
+	
+	
+	Log_Addr data(){
+    	message->class_id(Class::TASK);
+    	message->method_id(Method::Task::DATA);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Log_Addr data = reinterpret_cast<Log_Addr> message->return_value();
+		return data;
+    };
+
+	static Task * self() {
+		if (!message) {
+			Message * message = new Message();
+		}
+    	message->class_id(Class::TASK);
+    	message->method_id(Method::Task::SELF);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Task * task = reinterpret_cast<Task *> message->return_value();
+		return task;
+		
+    };
+
+private:
+   void * _obj_id;
+   Message * message;
+};
+
+__END_APP
+#endif
\ No newline at end of file
Index: include/stub/thread.h
===================================================================
--- include/stub/thread.h	(revision 0)
+++ include/stub/thread.h	(working copy)
@@ -0,0 +1,163 @@
+#ifndef __thread_h
+#define __thread_h
+
+#include <app_types.h>
+#include <stub/message.h>
+#include <stub/skeleton.h>
+
+__BEGIN_APP
+
+class Thread {
+
+public:
+	Thread(int (*entry)(Tn ...), Tn ... an) {
+		message = new Message();
+    	message->class_id(Class::THREAD);
+    	message->method_id(Method::Thread::CONSTRUCTOR_1);
+		message->variadic1[](void* (*entry)...);
+		message->variadic2[](void* an...);
+    	Skeleton::call(message);
+    	_obj_id = message->return_value();
+	}
+	
+	Thread(Task * task, int (*entry)(Tn ...), Tn ... an) {
+		message = new Message();
+    	message->class_id(Class::THREAD);
+    	message->method_id(Method::Thread::CONSTRUCTOR_2);
+		message->param1(void* task);
+		message->variadic1[](void* (*entry)...);
+		message->variadic2[](void* an...);
+    	Skeleton::call(message);
+    	_obj_id = message->return_value();
+	}
+	
+	Thread(const Configuration & conf, int (*entry)(Tn ...), Tn ... an) {
+		message = new Message();
+    	message->class_id(Class::THREAD);
+    	message->method_id(Method::Thread::CONSTRUCTOR_3);
+		message->param1(void* conf);
+		message->variadic1[](void* (*entry)...);
+		message->variadic2[](void* an...);
+    	Skeleton::call(message);
+    	_obj_id = message->return_value();
+	}
+	
+	Thread(const Configuration & conf, Task * task, int (*entry)(Tn ...), Tn ... an) {
+		message = new Message();
+    	message->class_id(Class::THREAD);
+    	message->method_id(Method::Thread::CONSTRUCTOR_4);
+		message->param1(void* conf);
+		message->param2(void* task);
+		message->variadic1[](void* (*entry)...);
+		message->variadic2[](void* an...);
+    	Skeleton::call(message);
+    	_obj_id = message->return_value();
+	}
+
+	~Thread() {
+		message->class_id(Class::THREAD);
+    	message->method_id(Method::Thread::DESTRUCTOR);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		delete message;
+	}
+	
+	const volatile State & state () const {
+		message->class_id(Class::THREAD);
+    	message->method_id(Method::Thread::STATE);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Thread * thread = reinterpret_cast<Thread *> message->return_value();
+		return thread->_state;
+	}
+	
+	const volatile Priority & priority() const {
+		message->class_id(Class::THREAD);
+    	message->method_id(Method::Thread::PRIORITY_1);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Thread * thread = reinterpret_cast<Thread *> message->return_value();
+		return thread->_link.rank();
+	}
+	
+	void priority() {
+		message->class_id(Class::THREAD);
+    	message->method_id(Method::Thread::PRIORITY_2);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Priority p = reinterpret_cast<Priority *> message->return_value();
+		return const &p;
+	}
+	
+	Task * task() const {
+		message->class_id(Class::THREAD);
+    	message->method_id(Method::Thread::TASK);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Task * task = reinterpret_cast<Task *> message->return_value();
+		return const_cast<Task*>(task);
+	}
+	
+	int join() {
+		message->class_id(Class::THREAD);
+    	message->method_id(Method::Thread::JOIN);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+		Thread * thread = reinterpret_cast<Thread *> message->return_value();
+		return thread->join();
+	}
+	
+	void pass() {
+		message->class_id(Class::THREAD);
+    	message->method_id(Method::Thread::PASS);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+	}
+	
+	void suspend() {
+		message->class_id(Class::THREAD);
+    	message->method_id(Method::Thread::SUSPEND);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+	}
+	
+	void resume() {
+		message->class_id(Class::THREAD);
+    	message->method_id(Method::Thread::RESUME);
+    	message->object_id(_obj_id);
+    	Skeleton::call(message);
+	}
+	
+	static Thread & volatile self() {
+		Message message = Message();
+		message.class_id(Class::THREAD);
+    	message.method_id(Method::Thread::SELF);
+    	message.object_id(_obj_id);
+    	Skeleton::call(message);
+		Thread * thread = reinterpret_cast<Thread *> message->return_value();
+		return thread->running();
+	}
+	
+	static void yield() {
+		Message message = Message();
+		message.class_id(Class::THREAD);
+    	message.method_id(Method::Thread::YIELD);
+    	message.object_id(_obj_id);
+    	Skeleton::call(message);
+	}
+	
+	static void exit() {
+		Message message = Message();
+		message.class_id(Class::THREAD);
+    	message.method_id(Method::Thread::EXIT);
+    	message.object_id(_obj_id);
+    	Skeleton::call(message);
+	}
+	
+private:
+	void * _obj_id;
+	Message * message;
+};
+
+__END_APP
+#endif
Index: include/system/config.h
===================================================================
--- include/system/config.h	(revision 3606)
+++ include/system/config.h	(working copy)
@@ -7,15 +7,15 @@
 // ARCHITECTURE, MACHINE, AND APPLICATION SELECTION
 // This section is generated automatically from makedefs by $EPOS/etc/makefile
 //============================================================================
-#define MODE xxx
-#define ARCH xxx
-#define MACH xxx
-#define MMOD xxx
-#define APPL xxx
-#define __mode_xxx__
-#define __arch_xxx__
-#define __mach_xxx__
-#define __mmod_xxx__
+#define MODE builtin
+#define ARCH ia32
+#define MACH pc
+#define MMOD legacy
+#define APPL test
+#define __mode_builtin__
+#define __arch_ia32__
+#define __mach_pc__
+#define __mmod_legacy__
 
 #if defined (__arch_avr__) || defined (__mmod_lm3s811__)
 #define __no_networking__
@@ -30,11 +30,17 @@
         using namespace U;
     }
 }
+namespace APP {}
 
 #define __BEGIN_API             namespace EPOS {
 #define __END_API               }
 #define _API                    ::EPOS
 
+#define __BEGIN_APP     		namespace EPOS { namespace APP {
+#define __END_APP       		} }
+#define __USING_APP     		using namespace EPOS::APP;
+#define _APP					::EPOS::APP
+
 #define __BEGIN_UTIL            namespace EPOS { namespace S { namespace U {
 #define __END_UTIL              }}}
 #define __USING_UTIL            using namespace S::U;
Index: include/system/traits.h
===================================================================
--- include/system/traits.h	(revision 3606)
+++ include/system/traits.h	(working copy)
@@ -17,7 +17,7 @@
 template<> struct Traits<Build>
 {
     enum {LIBRARY, BUILTIN};
-    static const unsigned int MODE = LIBRARY;
+    static const unsigned int MODE = BUILTIN;
 
     enum {IA32};
     static const unsigned int ARCHITECTURE = IA32;
Index: src/abstraction/.semaphore_test.cc.swo
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: src/abstraction/.semaphore_test.cc.swo
===================================================================
--- src/abstraction/.semaphore_test.cc.swo	(revision 0)
+++ src/abstraction/.semaphore_test.cc.swo	(working copy)

Property changes on: src/abstraction/.semaphore_test.cc.swo
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: src/abstraction/message.cc
===================================================================
--- src/abstraction/message.cc	(revision 0)
+++ src/abstraction/message.cc	(working copy)
@@ -0,0 +1,50 @@
+#include <stub/message.h>
+
+__BEGIN_API
+
+	void Message::class_id(int id) { _class_id = id; }
+	int Message::class_id() { return _class_id; }
+
+	void Message::method_id(int id) { _method_id = id; }
+	int Message::method_id() { return _method_id; }
+
+	void Message::object_id(void * id){ _object_id = id; }
+	void * Message::object_id(){ return _object_id; }
+
+	void Message::param1(void * ptr) { _param1 = ptr; }
+	void * Message::param1() { return _param1; }
+
+	void Message::param2(void * ptr) { _param2 = ptr; }
+	void * Message::param2() { return _param2; }
+
+	void Message::param3(void * ptr){ _param3 = ptr; }
+	void * Message::param3(){ return _param3; }
+
+	void Message::param4(void * ptr){ _param4 = ptr; }
+	void * Message::param4(){ return _param4; }
+
+	void Message::param5(void * ptr){ _param5 = ptr; }
+	void * Message::param5(){ return _param5; }
+
+	void Message::param6(void * ptr){ _param6 = ptr; }
+	void * Message::param6(){ return _param6; }
+
+	void Message::param7(void * ptr){ _param7 = ptr; }
+	void * Message::param7(){ return _param7; }
+
+	void variadic1(void...) { 
+		int size = sizeof...(void ...);
+		_variadic1[size] = {void ...};
+	}
+	void * variadic1[]() { return _variadic1[]; }
+	
+	void variadic2[](void ... *ptr) { 
+		int size = sizeof...(ptr);
+		_variadic2[size] = {ptr...};
+	}
+	void * variadic2[]() { return _variadic2[]; }
+	
+	void Message::return_value(void * ptr){ _return = ptr; }
+	void * Message::return_value(){ return _return; }
+
+__END_API
\ No newline at end of file
Index: src/abstraction/semaphore_test.cc
===================================================================
--- src/abstraction/semaphore_test.cc	(revision 3606)
+++ src/abstraction/semaphore_test.cc	(working copy)
@@ -2,21 +2,21 @@
 
 #include <utility/ostream.h>
 #include <thread.h>
-#include <mutex.h>
-#include <semaphore.h>
+#include <stub/mutex.h>
+#include <stub/semaphore.h>
 #include <alarm.h>
 #include <display.h>
 
-using namespace EPOS;
+//using namespace EPOS;
 
 const int iterations = 10;
 
-Mutex table;
+EPOS::Mutex table;
 
-Thread * phil[5];
-Semaphore * chopstick[5];
+EPOS::S::Thread * phil[5];
+EPOS::Semaphore * chopstick[5];
 
-OStream cout;
+EPOS::S::OStream cout;
 
 int philosopher(int n, int l, int c)
 {
@@ -26,21 +26,21 @@
     for(int i = iterations; i > 0; i--) {
 
         table.lock();
-        Display::position(l, c);
+        EPOS::S::Display::position(l, c);
         cout << "thinking";
         table.unlock();
 
-        Delay thinking(2000000);
+        EPOS::S::Delay thinking(2000000);
 
         chopstick[first]->p();   // get first chopstick
         chopstick[second]->p();   // get second chopstick
 
         table.lock();
-        Display::position(l, c);
+        EPOS::S::Display::position(l, c);
         cout << " eating ";
         table.unlock();
 
-        Delay eating(1000000);
+        EPOS::S::Delay eating(1000000);
 
         chopstick[first]->v();   // release first chopstick
         chopstick[second]->v();   // release second chopstick
@@ -47,7 +47,7 @@
     }
 
     table.lock();
-    Display::position(l, c);
+    EPOS::S::Display::position(l, c);
     cout << "  done  ";
     table.unlock();
 
@@ -57,41 +57,41 @@
 int main()
 {
     table.lock();
-    Display::clear();
-    Display::position(0, 0);
-    cout << "The Philosopher's Dinner:" << endl;
+    EPOS::S::Display::clear();
+    EPOS::S::Display::position(0, 0);
+    cout << "The Philosopher's Dinner:" << EPOS::S::endl;
 
     for(int i = 0; i < 5; i++)
-        chopstick[i] = new Semaphore;
+        chopstick[i] = new EPOS::Semaphore;
 
-    phil[0] = new Thread(&philosopher, 0,  5, 32);
-    phil[1] = new Thread(&philosopher, 1, 10, 44);
-    phil[2] = new Thread(&philosopher, 2, 16, 39);
-    phil[3] = new Thread(&philosopher, 3, 16, 24);
-    phil[4] = new Thread(&philosopher, 4, 10, 20);
+    phil[0] = new EPOS::S::Thread(&philosopher, 0,  5, 32);
+    phil[1] = new EPOS::S::Thread(&philosopher, 1, 10, 44);
+    phil[2] = new EPOS::S::Thread(&philosopher, 2, 16, 39);
+    phil[3] = new EPOS::S::Thread(&philosopher, 3, 16, 24);
+    phil[4] = new EPOS::S::Thread(&philosopher, 4, 10, 20);
 
-    cout << "Philosophers are alive and hungry!" << endl;
+    cout << "Philosophers are alive and hungry!" << EPOS::S::endl;
 
-    Display::position(7, 44);
+    EPOS::S::Display::position(7, 44);
     cout << '/';
-    Display::position(13, 44);
+    EPOS::S::Display::position(13, 44);
     cout << '\\';
-    Display::position(16, 35);
+    EPOS::S::Display::position(16, 35);
     cout << '|';
-    Display::position(13, 27);
+    EPOS::S::Display::position(13, 27);
     cout << '/';
-    Display::position(7, 27);
+    EPOS::S::Display::position(7, 27);
     cout << '\\';
-    Display::position(19, 0);
+    EPOS::S::Display::position(19, 0);
 
-    cout << "The dinner is served ..." << endl;
+    cout << "The dinner is served ..." << EPOS::S::endl;
     table.unlock();
 
     for(int i = 0; i < 5; i++) {
         int ret = phil[i]->join();
         table.lock();
-        Display::position(20 + i, 0);
-        cout << "Philosopher " << i << " ate " << ret << " times " << endl;
+        EPOS::S::Display::position(20 + i, 0);
+        cout << "Philosopher " << i << " ate " << ret << " times " << EPOS::S::endl;
         table.unlock();
     }
 
@@ -100,7 +100,7 @@
     for(int i = 0; i < 5; i++)
         delete phil[i];
 
-    cout << "The end!" << endl;
+    cout << "The end!" << EPOS::S::endl;
 
     return 0;
 }
Index: src/abstraction/skeleton.cc
===================================================================
--- src/abstraction/skeleton.cc	(revision 0)
+++ src/abstraction/skeleton.cc	(working copy)
@@ -0,0 +1,451 @@
+#include <stub/skeleton.h>
+#include <address_space.h>
+#include <alarm.h>
+#include <app_types.h>
+#include <condition.h>
+#include <mutex.h>
+#include <semaphore.h>
+#include <task.h>
+#include <display.h>
+//#include <segment.h>
+//#include <architecture/ia32/mmu.h>
+
+__BEGIN_SYS
+
+	void Skeleton::call(Message * m){
+		switch(m->class_id()){
+			case Class::ADDRESS_SPACE:
+				switch(m->method_id()){
+					case Method::Address_Space::CONSTRUCTOR_1: address_space_constructor_1(m); break;
+					case Method::Address_Space::CONSTRUCTOR_2: address_space_constructor_2(m); break;
+					case Method::Address_Space::DESTRUCTOR: address_space_destructor(m); break;
+					case Method::Address_Space::ATTACH_1: address_space_attach_1(m); break;
+					case Method::Address_Space::ATTACH_2: address_space_attach_2(m); break;
+					case Method::Address_Space::DETACH: address_space_detach(m); break;
+					case Method::Address_Space::PHYSICAL: address_space_physical(m); break;
+				}
+				break;
+			case Class::ALARM:
+				switch(m->method_id()){
+					case Method::Alarm::CONSTRUCTOR: alarm_constructor(m); break;
+					case Method::Alarm::DESTRUCTOR: alarm_destructor(m); break;
+					case Method::Alarm::FREQUENCY: alarm_frequency(m); break;
+					case Method::Alarm::DELAY: alarm_delay(m); break;
+				}
+				break;
+			case Class::CONDITION:
+				switch(m->method_id()){
+					case Method::Condition::CONSTRUCTOR: condition_constructor(m); break;
+					case Method::Condition::DESTRUCTOR: condition_destructor(m); break;
+					case Method::Condition::WAIT: condition_wait(m); break;
+					case Method::Condition::SIGNAL: condition_signal(m); break;
+					case Method::Condition::BROADCAST: condition_broadcast(m); break;
+				}
+				break;
+			case Class::DISPLAY:
+				switch(m->method_id()){
+					case Method::Display::CONSTRUCTOR: display_constructor(m); break;
+					case Method::Display::CLEAR: display_clear(m); break;
+					case Method::Display::PUTC: display_putc(m); break;
+					case Method::Display::PUTS: display_puts(m); break;
+					case Method::Display::GEOMETRY: display_geometry(m); break;
+					case Method::Display::POSITION_1: display_position_1(m); break;
+					case Method::Display::POSITION_2: display_position_2(m); break;
+				}
+				break;
+			case Class::HANDLER:
+				switch(m->method_id()){
+					case Method::Handler::CONSTRUCTOR: handler_constructor(m); break;
+					case Method::Handler::DESTRUCTOR: handler_destructor(m); break;
+					case Method::Handler::OPERATOR: handler_operator(m); break;
+				}
+				break;
+			case Class::MUTEX:
+				switch(m->method_id()){
+					case Method::Mutex::CONSTRUCTOR: mutex_constructor(m); break;
+					case Method::Mutex::DESTRUCTOR: mutex_destructor(m); break;
+					case Method::Mutex::LOCK: mutex_lock(m); break;
+					case Method::Mutex::UNLOCK: mutex_unlock(m); break;
+				}
+				break;
+			case Class::SEGMENT:
+				switch(m->method_id()){
+					case Method::Segment::CONSTRUCTOR_1: segment_constructor_1(m); break;
+					case Method::Segment::CONSTRUCTOR_2: segment_constructor_2(m); break;
+					case Method::Segment::DESTRUCTOR: segment_destructor(m); break;
+					case Method::Segment::SIZE: segment_size(m); break;
+					case Method::Segment::PHY_ADDRESS: segment_phy_address(m); break;
+					case Method::Segment::RESIZE: segment_resize(m); break;
+				}
+				break;
+			case Class::SEMAPHORE:
+				switch(m->method_id()){
+					case Method::Semaphore::CONSTRUCTOR: semaphore_constructor(m); break;
+					case Method::Semaphore::DESTRUCTOR: semaphore_destructor(m); break;
+					case Method::Semaphore::P: semaphore_p(m); break;
+					case Method::Semaphore::V: semaphore_v(m); break;
+				}
+				break;
+			case Class::TASK:
+				switch(m->method_id()) {
+					case Method::Task::CONSTRUCTOR: task_constructor(m); break;
+					case Method::Task::DESTRUCTOR: task_destructor(m); break;
+					case Method::Task::CODE_SEGMENT: task_code_segment(m); break;
+					case Method::Task::DATA_SEGMENT: task_data_segment(m); break;
+					case Method::Task::DATA: task_data(m); break;
+					case Method::Task::CODE: task_code(m); break;
+					case Method::Task::ADDRESS_SPACE: task_address_space(m); break;
+					case Method::Task::SELF: task_self(m); break;
+				}
+				break;
+			case Class::THREAD:
+				switch(m->method_id()) {
+					case Method::Thread::CONSTRUCTOR_1: thread_constructor_1(m); break;
+					case Method::Thread::CONSTRUCTOR_2: thread_constructor_2(m); break;
+					case Method::Thread::CONSTRUCTOR_3: thread_constructor_3(m); break;
+					case Method::Thread::CONSTRUCTOR_4: thread_constructor_4(m); break;
+					case Method::Thread::DESTRUCTOR: thread_destructor(m); break;
+					case Method::Thread::STATE: thread_state(m); break;
+					case Method::Thread::PRIORITY_1: thread_priority_1(m); break;
+					case Method::Thread::PRIORITY_2: thread_priority_2(m); break;
+					case Method::Thread::TASK: thread_task(m); break;
+					case Method::Thread::JOIN: thread_join(m); break;
+					case Method::Thread::PASS: thread_pass(m); break;
+					case Method::Thread::SUSPEND: thread_suspend(m); break;
+					case Method::Thread::RESUME: thread_resume(m); break;
+					case Method::Thread::SELF: thread_self(m); break;
+					case Method::Thread::YIELD: thread_yield(m); break;
+					case Method::Thread::EXIT: thread_exit(m); break;
+				}
+				break;
+		}
+	}
+	
+	// Address Space
+	void Skeleton::address_space_constructor_1(Message * m) {
+		Address_Space * address_space = new (SYSTEM) Address_Space();
+		m->return_value(reinterpret_cast<void *>(&address_space));
+	}
+	
+	void Skeleton::address_space_constructor_2(Message * m) {
+		MMU::Page_Directory pd = *reinterpret_cast<MMU::Page_Directory *>(m->param1());
+		Address_Space * address_space = new (SYSTEM) Address_Space(&pd);
+		m->return_value(reinterpret_cast<void *>(&address_space));
+	}
+	
+	void Skeleton::address_space_destructor(Message * m) {
+		Address_Space * address_space = reinterpret_cast<Address_Space *>(m->object_id());
+		delete address_space;
+	}
+	
+	void Skeleton::address_space_attach_1(Message * m) {
+		Address_Space * address_space = reinterpret_cast<Address_Space*>(m->object_id());
+		Segment p1 = *reinterpret_cast<Segment*>(m->param1());
+		CPU_Common::Log_Addr la = address_space->attach(p1);
+		m->return_value(reinterpret_cast<void *>(&la));
+	}
+	
+	void Skeleton::address_space_attach_2(Message * m) {
+		Address_Space * address_space = reinterpret_cast<Address_Space*>(m->object_id());
+		Segment seg = *reinterpret_cast<Segment*>(m->param1());
+		CPU_Common::Log_Addr log_addr = *reinterpret_cast<CPU_Common::Log_Addr *>(m->param2());
+		CPU_Common::Log_Addr la = address_space->attach(seg, log_addr);
+		m->return_value(reinterpret_cast<void *>(&la));
+	}
+	
+	void Skeleton::address_space_detach(Message * m) {
+		Address_Space * address_space = reinterpret_cast<Address_Space*>(m->object_id());
+		Segment seg = *reinterpret_cast<Segment*>(m->param1());
+		address_space->detach(seg);
+	}
+	
+	void Skeleton::address_space_physical(Message * m) {
+		CPU_Common::Log_Addr log_addr = *reinterpret_cast<CPU_Common::Log_Addr*>(m->param1());
+		Address_Space * address_space = reinterpret_cast<Address_Space*>(m->object_id());
+		address_space->physical(log_addr);
+	}
+	
+	// Alarm
+	void Skeleton::alarm_constructor(Message * m) {
+		const RTC::Microsecond times = *reinterpret_cast<RTC::Microsecond*>(m->param1());
+		Handler * handler = reinterpret_cast<Handler*>(m->param2());
+		int time = *reinterpret_cast<int*>(m->param3());
+		Alarm * alarm = new (SYSTEM) Alarm(times, handler, time);
+		m->return_value(reinterpret_cast<void *>(&alarm));
+	}
+	
+	void Skeleton::alarm_destructor(Message * m) {
+		Alarm * alarm = reinterpret_cast<Alarm *>(m->object_id());
+		delete alarm;
+	}
+	
+	void Skeleton::alarm_frequency(Message * m) {
+		Alarm * alarm = reinterpret_cast<Alarm*>(m->object_id());
+		alarm->frequency();
+	}
+	
+	void Skeleton::alarm_delay(Message * m) {
+		Alarm * alarm = reinterpret_cast<Alarm*>(m->object_id());
+		const RTC::Microsecond time = *reinterpret_cast<RTC::Microsecond*>(m->param1());
+		alarm->delay(time);
+	}
+
+	// Condition
+	void Skeleton::condition_constructor(Message * m) {
+		Condition * condition = new (SYSTEM) Condition();
+		m->return_value(reinterpret_cast<void *>(&condition));
+	}
+	
+	void Skeleton::condition_destructor(Message * m) {
+		Condition * condition = reinterpret_cast<Condition*>(m->object_id());
+		delete condition;
+	}
+	
+	void Skeleton::condition_wait(Message * m) {
+		Condition * condition = reinterpret_cast<Condition*>(m->object_id());
+		condition->wait();
+	}
+	
+	void Skeleton::condition_signal(Message * m) {
+		Condition * condition = reinterpret_cast<Condition*>(m->object_id());
+		condition->signal();
+	}
+	
+	void Skeleton::condition_broadcast(Message * m) {
+		Condition * condition = reinterpret_cast<Condition*>(m->object_id());
+		condition->broadcast();
+	}
+	
+	// Display
+	void Skeleton::display_constructor(Message * m) {
+		Serial_Display();
+	}
+	
+	void Skeleton::display_clear(Message * m) {
+		Display::clear();
+	}
+	
+	void Skeleton::display_putc(Message * m) {
+		char c = *reinterpret_cast<char*>(m->param1());
+		Display::putc(c);
+	}
+	
+	void Skeleton::display_puts(Message * m) {
+		const char s = *reinterpret_cast<char*>(m->param1());
+		Display::puts(&s);
+	}
+	
+	void Skeleton::display_geometry(Message * m) {
+		int * lines = reinterpret_cast<int*>(m->param1());
+		int * columns = reinterpret_cast<int*>(m->param2());
+		Display::geometry(lines, columns);
+	}
+	
+	void Skeleton::display_position_1(Message * m) {
+		int * line = reinterpret_cast<int*>(m->param1());
+		int * column = reinterpret_cast<int*>(m->param2());
+		Display::geometry(line, column);
+	}
+	
+	void Skeleton::display_position_2(Message * m) {
+		int line = *reinterpret_cast<int*>(m->param1());
+		int column = *reinterpret_cast<int*>(m->param2());
+		Display::geometry(&line, &column);
+	}
+	
+	// Handler
+	void Skeleton::handler_constructor(Message * m) {
+	
+	}
+	
+	void Skeleton::handler_destructor(Message * m) {
+	
+	}
+	
+	void Skeleton::handler_operator(Message * m) {
+	
+	}
+	
+	// Mutex
+	void Skeleton::mutex_constructor(Message * m) {
+		Mutex * mutex = new (SYSTEM) Mutex();
+		m->return_value(reinterpret_cast<void *>(&mutex));
+	}
+	
+	void Skeleton::mutex_destructor(Message * m) {
+		Mutex * mutex = reinterpret_cast<Mutex*>(m->object_id());
+		delete mutex;
+	}
+	
+	void Skeleton::mutex_lock(Message * m) {
+		Mutex * mutex = reinterpret_cast<Mutex*>(m->object_id());
+		mutex->lock();
+	}
+	
+	void Skeleton::mutex_unlock(Message * m) {
+		Mutex * mutex = reinterpret_cast<Mutex*>(m->object_id());
+		mutex->unlock();
+	}
+	
+	// Segment
+	void Skeleton::segment_constructor_1(Message * m) {
+	
+	}
+	
+	void Skeleton::segment_constructor_2(Message * m) {
+	
+	}
+	
+	void Skeleton::segment_destructor(Message * m) {
+	
+	}
+	
+	void Skeleton::segment_size(Message * m) {
+	
+	}
+	
+	void Skeleton::segment_phy_address(Message * m) {
+	
+	}
+	
+	void Skeleton::segment_resize(Message * m) {
+	
+	}
+	
+	// Semaphore
+	void Skeleton::semaphore_constructor(Message * m){
+		int v = reinterpret_cast<int>(m->param1());
+		Semaphore * sem = new (SYSTEM) Semaphore(v);
+		m->return_value(reinterpret_cast<void *>(&sem));
+	}
+
+	void Skeleton::semaphore_destructor(Message * m){
+		Semaphore * sem = reinterpret_cast<Semaphore*>(m->object_id());
+		delete sem;
+	}
+
+	void Skeleton::semaphore_p(Message * m){
+		Semaphore * sem = reinterpret_cast<Semaphore*>(m->object_id());
+		sem->p();
+	}
+
+	void Skeleton::semaphore_v(Message * m){
+		Semaphore * sem = reinterpret_cast<Semaphore*>(m->object_id());
+		sem->v();
+	}
+
+	// Task
+	void Skeleton::task_constructor(Message * m) {
+		Segment p1 = *reinterpret_cast<Segment*>(m->param1());
+		Segment p2 = *reinterpret_cast<Segment*>(m->param2());
+		Task * task = new (SYSTEM) Task(p1, p2);
+		m-> return_value(reinterpret_cast<void *>(&task));	
+	}
+	
+	void Skeleton::task_destructor(Message * m) {
+		Task * task = reinterpret_cast<Task*>(m->object_id());
+		delete task;
+	}
+	
+	void Skeleton::task_address_space(Message * m) {
+		Task * task = reinterpret_cast<Task*>(m->object_id());
+		Address_Space * address_space = task->address_space();
+		m->return_value(reinterpret_cast<void *> (address_space));
+	}
+	
+	void Skeleton::task_code_segment(Message * m) {
+		Task * task = reinterpret_cast<Task*>(m->object_id());
+		Segment * cs = const_cast<Segment *>(task->code_segment());
+		m->return_value(reinterpret_cast<void *>(cs));
+	}
+	
+	void Skeleton::task_code(Message * m) {
+		Task * task = reinterpret_cast<Task*>(m->object_id());
+		CPU_Common::Log_Addr code = task->code();
+		m->return_value(reinterpret_cast<void *>(&code));
+	}
+	
+	void Skeleton::task_data_segment(Message * m) {
+		Task * task = reinterpret_cast<Task*>(m->object_id());
+		Segment * ds = const_cast<Segment *>(task->data_segment());
+		m->return_value(reinterpret_cast<void *>(ds));
+	}
+	
+	void Skeleton::task_data(Message * m) {
+		Task * task = reinterpret_cast<Task*>(m->object_id());
+		CPU_Common::Log_Addr data = task->data();
+		m->return_value(reinterpret_cast<void *>(&data));
+	}
+	
+	void Skeleton::task_self(Message * m) {
+		Task * task = Task::self();
+		m->return_value(reinterpret_cast<void *>(task));
+	}
+	
+	// Thread
+	void Skeleton::thread_constructor_1(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_constructor_2(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_constructor_3(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_constructor_4(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_destructor(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_state(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_priority_1(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_priority_2(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_task(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_join(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_pass(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_suspend(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_resume(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_self(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_yield(Message * m) {
+	
+	}
+	
+	void Skeleton::thread_exit(Message * m) {
+	
+	}
+	
+
+__END_SYS
Index: src/architecture/ia32/ia32_crt0.s
===================================================================
--- src/architecture/ia32/ia32_crt0.s	(revision 0)
+++ src/architecture/ia32/ia32_crt0.s	(working copy)
@@ -0,0 +1,20 @@
+# 1 "ia32_crt0.S"
+# 1 "<built-in>"
+# 1 "<command-line>"
+# 1 "ia32_crt0.S"
+ .file "ia32_crt0.S"
+
+ .section .text
+ .align 4
+ .globl _start
+ .type _start,@function
+_start:
+ call _init
+ .align 4
+ .globl __epos_app_entry
+        .type __epos_app_entry,@function
+__epos_app_entry:
+ call main
+ push %eax
+ call _fini
+ call _exit
Index: src/boot/pc_boot
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: src/boot/pc_boot
===================================================================
--- src/boot/pc_boot	(revision 0)
+++ src/boot/pc_boot	(working copy)

Property changes on: src/boot/pc_boot
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: src/boot/pc_boot.s
===================================================================
--- src/boot/pc_boot.s	(revision 0)
+++ src/boot/pc_boot.s	(working copy)
@@ -0,0 +1,485 @@
+# 1 "pc_boot.S"
+# 1 "<built-in>"
+# 1 "<command-line>"
+# 1 "pc_boot.S"
+;==============================================================================
+; EPOS BOOT STRAP
+;
+; Desc: Reads system and applications from disk, initializes ix86
+; protected mode, get the size of memory from BIOS and jump into
+; SETUP. The boot strap is loaded by BIOS at 0x07c00
+;==============================================================================
+
+; CONSTANTS
+;==============================================================================
+; PHYSICAL MEMORY MAP
+; 0x0000 0000 -+-----------------------+ BOOT_IDT
+; | IDT (4 K) |
+; 0x0000 1000 -+-----------------------+ BOOT_GDT
+; | GDT (4 K) |
+; 0x0000 2000 -+-----------------------+
+; | SMP TRAMP. STACK (4 K)|
+; 0x0000 3000 -+-----------------------+ TRAMPOLINE_STACK, TRAMPOLINE_CODE
+; | SMP TRAMPOLINE (4 K) |
+; 0x0000 4000 -+-----------------------+
+; : :
+; | BOOT STACK (15 K) |
+; 0x0000 7c00 -+-----------------------+ BOOTSTRAP_STACK, BOOTSTRAP_CODE
+; | BOOT CODE (512 b) |
+; 0x0000 7e00 -+-----------------------+
+; | RESERVED (512 b) |
+; 0x0000 8000 -+-----------------------+ DISK_IMAGE
+; | DISK IMAGE (608 K) |
+; : :
+; | |
+; 0x000a 0000 -+-----------------------+
+; | UNUSED (384K) |
+; : :
+; | |
+; 0x000f f000 -+-----------------------+
+BOOT_IDT = 0x0000
+BOOT_GDT = 0x1000
+TRAMPOLINE_STACK = 0x3000 ; SMP trampoline stack (descendent, 4K)
+TRAMPOLINE_CODE = 0x3000 ; SMP trampoline code (4K)
+BOOTSTRAP_STACK = 0x7c00 ; Bootstrap stack (descendent, 15K)
+BOOTSTRAP_CODE = 0x7c00 ; Bootstrap code (512 bytes)
+DISK_IMAGE = 0x8000 ; = BOOT_IMAGE_PHY_ADDR from memory_map
+
+; The size of a disk sector in bytes
+DISK_SECT_SIZE = 512
+
+; The size of ELF object's header in bytes (GCC dependent)
+; Can be determined with objdump -p $(EPOS)/src/setup/pc_setup | sed -n -e 's/^ *LOAD off *\(0x.*\) vaddr.*$/\1/ p' | head -1
+ELF_HDR_SIZE = 0x00000060
+
+; DISK IMAGE LAYOUT
+; -+-----------------------+ DISK_IMAGE_SYS_INFO
+; | SYS_INFO (512 bytes) |
+; -+-----------------------+ DISK_IMAGE_SETUP
+; | SETUP |
+; : :
+; -+-----------------------+
+; | SYSTEM |
+; : :
+; -+-----------------------+
+; | INIT |
+; : :
+; -+-----------------------+
+; | LOADER/APP1 |
+; : :
+; -+-----------------------+
+; | APP1 |
+; : :
+; -+-----------------------+
+; : :
+; -+-----------------------+
+; | APPn |
+; : :
+; -+-----------------------+
+; BOOT IMAGE LAYOUT
+; System Information
+DISK_IMAGE_SYS_INFO = DISK_IMAGE
+
+; System Information
+DISK_IMAGE_SETUP = (DISK_IMAGE + DISK_SECT_SIZE)
+
+; SETUP entry point
+SETUP_ENTRY = (DISK_IMAGE_SETUP + ELF_HDR_SIZE)
+
+;==============================================================================
+; DEFINITIONS
+;==============================================================================
+; 8086 segment addresses
+IMAGE_SEG = DISK_IMAGE >> 4
+INFO_SEG = DISK_IMAGE_SYS_INFO >> 4
+
+.text
+
+;==============================================================================
+; MAIN
+;==============================================================================
+entry main
+main:
+  cli ; disable interrupts
+  xor ax,ax ; data segment base = 0x00000
+  mov ds,ax
+  mov es,ax
+  mov ss,ax
+                mov sp,#BOOTSTRAP_STACK ; set stack pointer
+
+; Prepare a trampoline for SMP initialization
+  call setup_trampoline
+
+; Load the boot image from the disk into "DISK_IMAGE"
+                mov si,#msg_loading
+  call print_msg
+  push es
+                mov ax,#IMAGE_SEG
+  mov es,ax ; don't try to load es directly;
+                mov bx,#0 ; set es:bx to DISK_IMAGE
+                mov ax,[n_sec_image]
+                mov cx,#0x0002 ; starts at track #0, sector #2,
+                mov dx,#0x0000 ; side #0, first drive
+                call load_image
+  pop es
+                mov si,#msg_done
+  call print_msg
+
+; Stop the drive motor
+                call stop_drive
+
+; Get extended memory size (in K)
+; xor dx,dx
+; mov ah,#0x88
+; int 0x15 ; what if memory size > 64 Mb?
+; push ds
+; push #INFO_SEG
+; pop ds
+; mov [0],ax
+; mov [2],dx
+; pop ds
+
+; Say hello;
+  mov si,#msg_hello
+  call print_msg
+
+; Enable A20 bus line
+  call enable_a20
+
+; Zero IDT and GDT
+                cld
+                xor ax,ax
+                mov cx,#0x1000 ; IDT + GDT = 8K (4K WORDS)
+                mov di,#BOOT_IDT ; initial address (relative to ES)
+  rep ; zero IDT and GDT with AX
+  stosw
+
+; Set GDT
+                mov si,#GDT_CODE ; Set GDT[1]=GDT_CODE and
+                mov di,#BOOT_GDT ; GDT[2]=GDT_DATA
+                add di,#8 ; offset GDT[1] = 8
+                mov cx,#8 ; sizeof GDT[1] + GDT[2] = 8 WORDS
+  rep ; move WORDS
+  movsw
+
+; Set GDTR
+                lgdt GDTR
+
+; Enable Protected Mode
+                mov eax,cr0
+                or al,#0x01 ; set PE flag and MP flag
+                mov cr0,eax
+
+; Adjust selectors
+                mov bx,#2 * 8 ; adjust data selectors to use
+                mov ds,bx ; GDT[2] (DATA) with RPL = 00
+                mov es,bx
+                mov fs,bx
+                mov gs,bx
+                mov ss,bx
+
+; As Linux as86 can't generate 32 bit instructions, we have to code it by hand.
+; The instruction below is a inter segment jump to GDT[GDT_CODE]:SETUP.
+; Jump into "SETUP" (actually ix86 Protected Mode starts here)
+; jmp 0x0008:#SETUP_ENTRY
+  .byte 0x66
+  .byte 0xEA
+  .long SETUP_ENTRY
+  .word 0x0008
+
+;==============================================================================
+; PRINT_MSG
+;
+; Desc: Print a \0 terminated string on the screen using the BIOS
+; Message must end with 00h
+;
+; Parm: si -> pointer to the string
+;==============================================================================
+print_msg:
+                pushf
+                push ax
+                push bx
+                push bp
+                cld
+
+print_char:
+                lodsb
+                cmp al,#0
+                jz end_print
+                mov ah,#0x0E
+                mov bx,#0x0007
+                int 0x10
+                jmp print_char
+
+end_print:
+  pop bp
+                pop bx
+                pop ax
+                popf
+                ret
+
+;==============================================================================
+; SAY_Z
+;
+; Desc: Print 'z' on the screen.
+;==============================================================================
+say_z:
+                pushf
+                push si
+                mov si,#msg_z
+                call print_msg
+                pop si
+                popf
+                ret
+
+;==============================================================================
+; STOP_DRIVE
+;
+; Desc: Stops the drive motor.
+;==============================================================================
+stop_drive:
+                pushf
+                push ax
+                push dx
+                mov dx,#0x03F2
+                xor al,al
+                out dx,al
+                pop dx
+                pop ax
+                popf
+                ret
+
+;==============================================================================
+; LOAD_ONE_SECTOR
+;
+; Desc: Load a single sector from disk using the BIOS.
+;
+; Parm: es:bx -> buffer
+; cx -> track (ch) and sector number (cl)
+; dx -> side (dh) and drive number (dl)
+;==============================================================================
+load_sector:
+  pushf
+  push ax
+
+                mov ax,#0x0201 ; function #2, load 1 sector
+                int 0x13
+                cli ; int 0x13 sets IF
+                jc ls_disk_error ; if CY=1, error on reading
+
+  pop ax
+  popf
+                ret
+
+ls_disk_error:
+                mov si,#msg_disk_error
+                call print_msg ; print error msg if disk is bad
+                call stop_drive
+ls_disk_halt:
+                jmp ls_disk_halt ; halt
+
+;========================================================================
+; LOAD_IMAGE
+;
+; Desc: Load the the image from disk into a buffer.
+;
+; Parm: es:bx -> buffer
+; ax -> number of sectors to load
+; cx -> initial track (ch) and sector number (cl)
+; dx -> inital side (dh) and drive number (dl)
+;========================================================================
+load_image:
+  pushf
+  push ax
+  push bx
+  push cx
+  push dx
+  push es
+
+li_check:
+                cmp ax,#0
+                jz li_done
+                call load_sector
+  push ax
+  mov ax,es
+  add ax,#0x20 ; get next buffer position
+  mov es,ax
+  pop ax
+  dec ax
+                inc cl ; get next sector
+                cmp cl,#19 ; was this last sector?
+                jnz li_next
+                mov cl, #1
+                inc dh ; get next side
+                cmp dh, #2 ; read both?
+                jnz li_next
+                mov dh, #0
+                inc ch ; get next track
+                call say_z
+li_next:
+                jmp li_check
+
+li_done:
+  pop es
+  pop dx
+  pop cx
+  pop bx
+  pop ax
+  popf
+                ret
+
+;========================================================================
+; ENABLE_A20
+;
+; Desc: Enables the 20th address bus line by writing some bytes to the
+; keyboard port.
+;========================================================================
+enable_a20:
+                pushf
+                push ax
+
+   call keyb_flush ; empty keyb controller
+  mov al,#0xd1 ; keyb->cmd = write
+  out #0x64,al
+  call keyb_flush
+  mov al,#0xdf ; keyb->data = 0xdf
+  outb #0x60,al
+  call keyb_flush
+
+                pop ax
+                popf
+                ret
+
+;========================================================================
+; FLUSH_KEYB
+;
+; Desc: Flushes the keyboard controler
+;========================================================================
+keyb_flush:
+                pushf
+                push ax
+
+kf_stat: call kf_delay
+  in al,#0x64 ; get keyb status
+         test al,#1 ; output buffer full?
+         jz kf_emptyt
+         call kf_delay
+         in al,#0x60 ; get data
+         jmp kf_stat
+kf_emptyt: test al,#2 ; input buffer full?
+         jnz kf_stat
+
+                pop ax
+                popf
+                ret
+
+kf_delay: ret
+
+;========================================================================
+; SETUP_TRAMPOLIE
+;
+; Desc: copy the SMP trampoline code to a page-aligned address
+;========================================================================
+setup_trampoline:
+  mov si,#trampoline
+  mov di,#TRAMPOLINE_CODE
+  cld
+  mov cx,#100
+  rep
+  movsb
+  ret
+
+;========================================================================
+; TRAMPOLIE
+;
+; Desc: "trampolines" additional CPUs into protected mode in SMP
+; configurations =
+;========================================================================
+trampoline:
+  cli ; disable interrupts
+  xor ax,ax ; data segment base = 0x00000
+  mov ds,ax
+  mov es,ax
+  mov ss,ax
+                mov sp,#TRAMPOLINE_STACK ; set stack pointer
+ ;; mov [0xB8004], #(0x32 & 0xFF) ;
+
+; Set GDTR
+                lgdt GDTR
+
+; Enable Protected Mode
+                mov eax,cr0
+                or al,#0x01 ; set PE flag and MP flag
+                mov cr0,eax
+
+; Adjust selectors
+                mov bx,#2 * 8 ; adjust data selectors to use
+                mov ds,bx ; GDT[2] (DATA) with RPL = 00
+                mov es,bx
+                mov fs,bx
+                mov gs,bx
+                mov ss,bx
+
+; As Linux as86 can't generate 32 bit instructions, we have to code it by hand.
+; The instruction below is a inter segment jump to GDT[GDT_CODE]:SETUP.
+; Jump into "SETUP" (actually ix86 Protected Mode starts here)
+; jmp 0x0008:#SETUP_ENTRY
+  .byte 0x66
+  .byte 0xEA
+  .long SETUP_ENTRY
+  .word 0x0008
+
+;==============================================================================
+; DATA SEGMENT
+;==============================================================================
+GDTR:
+  .word 0x0FFF ; GDT limit - 4K
+  .long 0x00001000 ; GDT base address - also 4K
+
+GDT_CODE:
+  .word 0xFFFF ; limit 15:00
+                .word 0x0000 ; base 15:00
+                .byte 0x00 ; base 23:16
+                .byte 0x9A ; 10011001 flags (p/dpl/s/code/c/w/a)
+                .byte 0xCF ; 11001111 (g/d/0/avl) & limit 19:16
+                .byte 0x00 ; base 31:24
+
+GDT_DATA:
+  .word 0xFFFF ; limit 15:00
+                .word 0x0000 ; base 15:00
+                .byte 0x00 ; base 23:16
+                .byte 0x92 ; 10010011 flags (p/dpl/s/data/e/w/a)
+                .byte 0xCF ; 11001111 (g/d/0/avl) & limit 19:16
+                .byte 0x00 ; base 31:24
+
+msg_disk_error:
+  .ascii "Disk error: system halted;"
+  .word 0x0D0A
+  .byte 0x00
+
+msg_hello:
+  .ascii "This is EPOS;"
+  .word 0x0D0A
+  .byte 0x00
+
+msg_z:
+  .ascii "."
+  .byte 0x00
+
+msg_loading:
+                .ascii "Loading EPOS "
+  .byte 0x00
+
+msg_done:
+  .ascii " done;"
+  .word 0x0D0A
+  .byte 0x00
+
+; The following is to enable "sys" to define the actual size of the image.
+; The default value of 360 will be only used if you don't use sys.
+  .align 508
+n_sec_image:
+  .word 360
+
+; Tag the boot sector as "bootable"
+  .word 0xAA55
Index: src/init/pc_init
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: src/init/pc_init
===================================================================
--- src/init/pc_init	(revision 0)
+++ src/init/pc_init	(working copy)

Property changes on: src/init/pc_init
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: src/setup/pc_setup
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: src/setup/pc_setup
===================================================================
--- src/setup/pc_setup	(revision 0)
+++ src/setup/pc_setup	(working copy)

Property changes on: src/setup/pc_setup
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: src/system/pc_system
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: src/system/pc_system
===================================================================
--- src/system/pc_system	(revision 0)
+++ src/system/pc_system	(working copy)

Property changes on: src/system/pc_system
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: tools/eposmkbi/eposmkbi
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: tools/eposmkbi/eposmkbi
===================================================================
--- tools/eposmkbi/eposmkbi	(revision 0)
+++ tools/eposmkbi/eposmkbi	(working copy)

Property changes on: tools/eposmkbi/eposmkbi
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
